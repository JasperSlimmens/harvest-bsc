{
  "language": "Solidity",
  "sources": {
    "contracts/lib/@harvest-finance/Controllable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\nimport {Governable} from \"./Governable.sol\";\n\ncontract Controllable is Governable {\n\n  constructor(address _storage) Governable(_storage) public {\n  }\n\n  modifier onlyController() {\n    require(store.isController(msg.sender), \"Not a controller\");\n    _;\n  }\n\n  modifier onlyControllerOrGovernance(){\n    require((store.isController(msg.sender) || store.isGovernance(msg.sender)),\n      \"The caller must be controller or governance\");\n    _;\n  }\n\n  function controller() public view returns (address) {\n    return store.controller();\n  }\n}\n"
    },
    "contracts/lib/@harvest-finance/Governable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\nimport {Storage} from \"./Storage.sol\";\n\ncontract Governable {\n\n  Storage public store;\n\n  constructor(address _store) public {\n    require(_store != address(0), \"new storage shouldn't be empty\");\n    store = Storage(_store);\n  }\n\n  modifier onlyGovernance() {\n    require(store.isGovernance(msg.sender), \"Not governance\");\n    _;\n  }\n\n  function setStorage(address _store) public onlyGovernance {\n    require(_store != address(0), \"new storage shouldn't be empty\");\n    store = Storage(_store);\n  }\n\n  function governance() public view returns (address) {\n    return store.governance();\n  }\n}\n"
    },
    "contracts/lib/@harvest-finance/Storage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\ncontract Storage {\n\n  address public governance;\n  address public controller;\n\n  constructor() public {\n    governance = msg.sender;\n  }\n\n  modifier onlyGovernance() {\n    require(isGovernance(msg.sender), \"Not governance\");\n    _;\n  }\n\n  function setGovernance(address _governance) public onlyGovernance {\n    require(_governance != address(0), \"new governance shouldn't be empty\");\n    governance = _governance;\n  }\n\n  function setController(address _controller) public onlyGovernance {\n    require(_controller != address(0), \"new controller shouldn't be empty\");\n    controller = _controller;\n  }\n\n  function isGovernance(address account) public view returns (bool) {\n    return account == governance;\n  }\n\n  function isController(address account) public view returns (bool) {\n    return account == controller;\n  }\n}\n"
    },
    "contracts/lib/@harvest-finance/VaultFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\nimport \"./VaultProxy.sol\";\nimport \"./Vault.sol\";\nimport \"./Controllable.sol\";\n\ncontract VaultFactory is Controllable {\n\n  event NewVault(address vault);\n\n  constructor(address _storage) Controllable(_storage) public {}\n\n  function createVault(\n    address _implementation,\n    address _storage,\n    address _underlying,\n    uint256 _toInvestNumerator,\n    uint256 _toInvestDenominator\n  ) public onlyGovernance returns(address) {\n    VaultProxy proxy = new VaultProxy(_implementation);\n    Vault(address(proxy)).initializeVault(\n      _storage,\n      _underlying,\n      _toInvestNumerator,\n      _toInvestDenominator\n    );\n    emit NewVault(address(proxy));\n    return address(proxy);\n  }\n}\n"
    },
    "contracts/lib/@harvest-finance/VaultProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\nimport \"./hardworkInterface/IUpgradeSource.sol\";\nimport \"../@openzeppelin/upgrades/upgradeability/BaseUpgradeabilityProxy.sol\";\n\ncontract VaultProxy is BaseUpgradeabilityProxy {\n\n  constructor(address _implementation) public {\n    _setImplementation(_implementation);\n  }\n\n  /**\n  * The main logic. If the timer has elapsed and there is a schedule upgrade,\n  * the governance can upgrade the vault\n  */\n  function upgrade() external {\n    (bool should, address newImplementation) = IUpgradeSource(address(this)).shouldUpgrade();\n    require(should, \"Upgrade not scheduled\");\n    _upgradeTo(newImplementation);\n\n    // the finalization needs to be executed on itself to update the storage of this proxy\n    // it also needs to be invoked by the governance, not by address(this), so delegatecall is needed\n    (bool success, bytes memory result) = address(this).delegatecall(\n      abi.encodeWithSignature(\"finalizeUpgrade()\")\n    );\n\n    require(success, \"Issue when finalizing the upgrade\");\n  }\n\n  function implementation() external view returns (address) {\n    return _implementation();\n  }\n}\n"
    },
    "contracts/lib/@harvest-finance/Vault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\nimport {MathUpgradeable} from \"@openzeppelin/contracts-upgradeable/math/MathUpgradeable.sol\";\nimport {SafeMathUpgradeable} from \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol\";\nimport {IERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport {ERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport {AddressUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\n// import \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20DetailedUpgradeable.sol\";\nimport {IStrategy} from \"./hardworkInterface/IStrategy.sol\";\nimport {IStrategyV2} from \"./hardworkInterface/IStrategyV2.sol\";\nimport {IVault} from \"./hardworkInterface/IVault.sol\";\nimport {IController} from \"./hardworkInterface/IController.sol\";\nimport {IUpgradeSource} from \"./hardworkInterface/IUpgradeSource.sol\";\nimport {ControllableInit} from \"./ControllableInit.sol\";\nimport {VaultStorage} from \"./VaultStorage.sol\";\n\ncontract Vault is ERC20Upgradeable, IVault, IUpgradeSource, ControllableInit, VaultStorage {\n  using SafeERC20Upgradeable for IERC20Upgradeable;\n  using AddressUpgradeable for address;\n  using SafeMathUpgradeable for uint256;\n\n  event Withdraw(address indexed beneficiary, uint256 amount);\n  event Deposit(address indexed beneficiary, uint256 amount);\n  event Invest(uint256 amount);\n  event StrategyAnnounced(address newStrategy, uint256 time);\n  event StrategyChanged(address newStrategy, address oldStrategy);\n\n  modifier whenStrategyDefined() {\n    require(address(strategy()) != address(0), \"Strategy must be defined\");\n    _;\n  }\n\n  // Only smart contracts will be affected by this modifier\n  modifier defense() {\n    require(\n      (msg.sender == tx.origin) ||                // If it is a normal user and not smart contract,\n      // then the requirement will pass\n      !IController(controller()).greyList(msg.sender), // If it is a smart contract, then\n      \"This smart contract has been grey listed\"  // make sure that it is not on our greyList.\n    );\n    _;\n  }\n\n  constructor() public {\n  }\n\n  // the function is name differently to not cause inheritance clash in truffle and allows tests\n  function initializeVault(\n    address _storage,\n    address _underlying,\n    uint256 _toInvestNumerator,\n    uint256 _toInvestDenominator\n  ) public initializer {\n    require(_toInvestNumerator <= _toInvestDenominator, \"cannot invest more than 100%\");\n    require(_toInvestDenominator != 0, \"cannot divide by 0\");\n\n    __ERC20_init(\n      string(abi.encodePacked(\"bFARM_\", ERC20Upgradeable(_underlying).symbol())),\n      string(abi.encodePacked(\"bf\", ERC20Upgradeable(_underlying).symbol()))\n    );\n    _setupDecimals(ERC20Upgradeable(_underlying).decimals());\n\n    ControllableInit.initialize(\n      _storage\n    );\n\n    uint256 underlyingUnit = 10 ** uint256(ERC20Upgradeable(address(_underlying)).decimals());\n    uint256 implementationDelay = 12 hours;\n    uint256 strategyChangeDelay = 12 hours;\n    VaultStorage.initialize(\n      _underlying,\n      _toInvestNumerator,\n      _toInvestDenominator,\n      underlyingUnit,\n      implementationDelay,\n      strategyChangeDelay\n    );\n  }\n\n  function strategy() public view override returns(address) {\n    return _strategy();\n  }\n\n  function underlying() public view override returns(address) {\n    return _underlying();\n  }\n\n  function underlyingUnit() public view returns(uint256) {\n    return _underlyingUnit();\n  }\n\n  function vaultFractionToInvestNumerator() public view returns(uint256) {\n    return _vaultFractionToInvestNumerator();\n  }\n\n  function vaultFractionToInvestDenominator() public view returns(uint256) {\n    return _vaultFractionToInvestDenominator();\n  }\n\n  function nextImplementation() public view returns(address) {\n    return _nextImplementation();\n  }\n\n  function nextImplementationTimestamp() public view returns(uint256) {\n    return _nextImplementationTimestamp();\n  }\n\n  function nextImplementationDelay() public view returns(uint256) {\n    return _nextImplementationDelay();\n  }\n\n  /**\n  * Chooses the best strategy and re-invests. If the strategy did not change, it just calls\n  * doHardWork on the current strategy. Call this through controller to claim hard rewards.\n  */\n  function doHardWork() external override whenStrategyDefined onlyControllerOrGovernance {\n    uint256 sharePriceBeforeHardWork = getPricePerFullShare();\n    if (_withdrawBeforeReinvesting()) {\n      IStrategy(strategy()).withdrawAllToVault();\n    }\n\n    // ensure that new funds are invested too\n    invest();\n    IStrategy(strategy()).doHardWork();\n    uint256 sharePriceAfterHardWork = getPricePerFullShare();\n\n    if (!allowSharePriceDecrease()) {\n      require(sharePriceBeforeHardWork <= sharePriceAfterHardWork, \"Share price should not decrease\");\n    }\n  }\n\n  /*\n  * Returns the cash balance across all users in this contract.\n  */\n  function underlyingBalanceInVault() view public override returns (uint256) {\n    return IERC20Upgradeable(underlying()).balanceOf(address(this));\n  }\n\n  /* Returns the current underlying (e.g., DAI's) balance together with\n   * the invested amount (if DAI is invested elsewhere by the strategy).\n  */\n  function underlyingBalanceWithInvestment() view public override returns (uint256) {\n    if (address(strategy()) == address(0)) {\n      // initial state, when not set\n      return underlyingBalanceInVault();\n    }\n    return underlyingBalanceInVault().add(IStrategy(strategy()).investedUnderlyingBalance());\n  }\n\n  function getPricePerFullShare() public view override returns (uint256) {\n    return totalSupply() == 0\n        ? underlyingUnit()\n        : underlyingUnit().mul(underlyingBalanceWithInvestment()).div(totalSupply());\n  }\n\n  function getEstimatedWithdrawalAmount(uint256 numberOfShares) public view returns (uint256 realTimeCalculatedValue) {\n    return numberOfShares.mul(getPricePerFullShare()).div(underlyingUnit());\n  }\n\n  function underlyingBalanceWithInvestmentForHolder(address holder) view external override returns (uint256) {\n    // for compatibility\n    uint256 estimatedWithdrawal = getEstimatedWithdrawalAmount(balanceOf(holder));\n    return estimatedWithdrawal;\n  }\n\n  function futureStrategy() public view returns (address) {\n    return _futureStrategy();\n  }\n\n  function strategyUpdateTime() public view returns (uint256) {\n    return _strategyUpdateTime();\n  }\n\n  function strategyTimeLock() public view returns (uint256) {\n    return _strategyTimeLock();\n  }\n\n  function canUpdateStrategy(address _strategy) public view returns(bool) {\n    return strategy() == address(0) // no strategy was set yet\n      || (_strategy == futureStrategy()\n          && block.timestamp > strategyUpdateTime()\n          && strategyUpdateTime() > 0); // or the timelock has passed\n  }\n\n  /**\n  * Indicates that the strategy update will happen in the future\n  */\n  function announceStrategyUpdate(address _strategy) public onlyControllerOrGovernance {\n    // records a new timestamp\n    uint256 when = block.timestamp.add(strategyTimeLock());\n    _setStrategyUpdateTime(when);\n    _setFutureStrategy(_strategy);\n    emit StrategyAnnounced(_strategy, when);\n  }\n\n  /**\n  * Finalizes (or cancels) the strategy update by resetting the data\n  */\n  function finalizeStrategyUpdate() public onlyControllerOrGovernance {\n    _setStrategyUpdateTime(0);\n    _setFutureStrategy(address(0));\n  }\n\n  function setStrategy(address _strategy) public override onlyControllerOrGovernance {\n    require(canUpdateStrategy(_strategy),\n      \"The strategy exists and switch timelock did not elapse yet\");\n    require(_strategy != address(0), \"new _strategy cannot be empty\");\n    require(IStrategy(_strategy).underlying() == address(underlying()), \"Vault underlying must match Strategy underlying\");\n    require(IStrategy(_strategy).vault() == address(this), \"the strategy does not belong to this vault\");\n\n    emit StrategyChanged(_strategy, strategy());\n    if (address(_strategy) != address(strategy())) {\n      if (address(strategy()) != address(0)) { // if the original strategy (no underscore) is defined\n        IERC20Upgradeable(underlying()).safeApprove(address(strategy()), 0);\n        IStrategy(strategy()).withdrawAllToVault();\n      }\n      _setStrategy(_strategy);\n      IERC20Upgradeable(underlying()).safeApprove(address(strategy()), 0);\n      IERC20Upgradeable(underlying()).safeApprove(address(strategy()), uint256(~0));\n    }\n    finalizeStrategyUpdate();\n  }\n\n  function setVaultFractionToInvest(uint256 numerator, uint256 denominator) external override onlyGovernance {\n    require(denominator > 0, \"denominator must be greater than 0\");\n    require(numerator <= denominator, \"denominator must be greater than or equal to the numerator\");\n    _setVaultFractionToInvestNumerator(numerator);\n    _setVaultFractionToInvestDenominator(denominator);\n  }\n\n  function setWithdrawBeforeReinvesting(bool value) external onlyGovernance {\n    _setWithdrawBeforeReinvesting(value);\n  }\n\n  function withdrawBeforeReinvesting() public view returns (bool) {\n    return _withdrawBeforeReinvesting();\n  }\n\n  function setAllowSharePriceDecrease(bool value) external onlyGovernance {\n    _setAllowSharePriceDecrease(value);\n  }\n\n  function allowSharePriceDecrease() public view returns (bool) {\n    return _allowSharePriceDecrease();\n  }\n\n  function availableToInvestOut() public view returns (uint256) {\n    uint256 wantInvestInTotal = underlyingBalanceWithInvestment()\n        .mul(vaultFractionToInvestNumerator())\n        .div(vaultFractionToInvestDenominator());\n    uint256 alreadyInvested = IStrategy(strategy()).investedUnderlyingBalance();\n    if (alreadyInvested >= wantInvestInTotal) {\n      return 0;\n    } else {\n      uint256 remainingToInvest = wantInvestInTotal.sub(alreadyInvested);\n      return remainingToInvest <= underlyingBalanceInVault()\n        // TODO: we think that the \"else\" branch of the ternary operation is not\n        // going to get hit\n        ? remainingToInvest : underlyingBalanceInVault();\n    }\n  }\n\n  function invest() internal whenStrategyDefined {\n    uint256 availableAmount = availableToInvestOut();\n    if (availableAmount > 0) {\n      IERC20Upgradeable(underlying()).safeTransfer(address(strategy()), availableAmount);\n      emit Invest(availableAmount);\n    }\n  }\n\n  /*\n  * Allows for depositing the underlying asset in exchange for shares.\n  * Approval is assumed.\n  */\n  function deposit(uint256 amount) external override defense {\n    _deposit(amount, msg.sender, msg.sender);\n  }\n\n  /*\n  * Allows for depositing the underlying asset in exchange for shares\n  * assigned to the holder.\n  * This facilitates depositing for someone else (using DepositHelper)\n  */\n  function depositFor(uint256 amount, address holder) public override defense {\n    _deposit(amount, msg.sender, holder);\n  }\n\n  function withdrawAll() public override onlyControllerOrGovernance whenStrategyDefined {\n    IStrategy(strategy()).withdrawAllToVault();\n  }\n\n  function withdraw(uint256 numberOfShares) external override {\n    require(totalSupply() > 0, \"Vault has no shares\");\n    require(numberOfShares > 0, \"numberOfShares must be greater than 0\");\n    uint256 totalShareSupply = totalSupply();\n    _burn(msg.sender, numberOfShares);\n\n    uint256 calculatedSharePrice = getPricePerFullShare();\n\n    uint256 underlyingAmountToWithdraw = numberOfShares\n      .mul(calculatedSharePrice)\n      .div(underlyingUnit());\n\n    if (underlyingAmountToWithdraw > underlyingBalanceInVault()) {\n      // withdraw everything from the strategy to accurately check the share value\n      if (numberOfShares == totalShareSupply) {\n        IStrategy(strategy()).withdrawAllToVault();\n        underlyingAmountToWithdraw = underlyingBalanceInVault();\n      } else {\n        uint256 missingUnderlying = underlyingAmountToWithdraw.sub(underlyingBalanceInVault());\n        uint256 missingShares = numberOfShares.mul(missingUnderlying).div(underlyingAmountToWithdraw);\n        // When withdrawing to vault here, the vault does not have any assets. Therefore,\n        // all the assets that are in the strategy match the total supply of shares, increased\n        // by the share proportion that was already burned at the beginning of this withdraw transaction.\n        IStrategyV2(strategy()).withdrawToVault(missingShares, (totalSupply()).add(missingShares));\n        // recalculate to improve accuracy\n        calculatedSharePrice = getPricePerFullShare();\n\n        uint256 updatedUnderlyingAmountToWithdraw = numberOfShares\n          .mul(calculatedSharePrice)\n          .div(underlyingUnit());\n\n        underlyingAmountToWithdraw = MathUpgradeable.min(\n          updatedUnderlyingAmountToWithdraw,\n          underlyingBalanceInVault()\n        );\n      }\n    }\n\n    IERC20Upgradeable(underlying()).safeTransfer(msg.sender, underlyingAmountToWithdraw);\n\n    // update the withdrawal amount for the holder\n    emit Withdraw(msg.sender, underlyingAmountToWithdraw);\n  }\n\n  function _deposit(uint256 amount, address sender, address beneficiary) internal {\n    require(amount > 0, \"Cannot deposit 0\");\n    require(beneficiary != address(0), \"holder must be defined\");\n\n    if (address(strategy()) != address(0)) {\n      require(IStrategy(strategy()).depositArbCheck(), \"Too much arb\");\n    }\n\n    uint256 toMint = amount.mul(underlyingUnit()).div(getPricePerFullShare());\n\n    _mint(beneficiary, toMint);\n\n    IERC20Upgradeable(underlying()).safeTransferFrom(sender, address(this), amount);\n\n    // update the contribution amount for the beneficiary\n    emit Deposit(beneficiary, amount);\n  }\n\n  /**\n  * Schedules an upgrade for this vault's proxy.\n  */\n  function scheduleUpgrade(address impl) public onlyGovernance {\n    _setNextImplementation(impl);\n    _setNextImplementationTimestamp(block.timestamp.add(nextImplementationDelay()));\n  }\n\n  function shouldUpgrade() external view override returns (bool, address) {\n    return (\n      nextImplementationTimestamp() != 0\n        && block.timestamp > nextImplementationTimestamp()\n        && nextImplementation() != address(0),\n      nextImplementation()\n    );\n  }\n\n  function finalizeUpgrade() external override onlyGovernance {\n    _setNextImplementation(address(0));\n    _setNextImplementationTimestamp(0);\n    // for vaults V3\n    _setAllowSharePriceDecrease(false);\n    _setWithdrawBeforeReinvesting(false);\n    require(!withdrawBeforeReinvesting(), \"withdrawBeforeReinvesting is incorrect\");\n    require(!allowSharePriceDecrease(), \"allowSharePriceDecrease is incorrect\");\n  }\n}\n"
    },
    "contracts/lib/@harvest-finance/hardworkInterface/IUpgradeSource.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\ninterface IUpgradeSource {\n  function shouldUpgrade() external view returns (bool, address);\n  function finalizeUpgrade() external;\n}\n"
    },
    "contracts/lib/@openzeppelin/upgrades/upgradeability/BaseUpgradeabilityProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport './Proxy.sol';\nimport '../utils/Address.sol';\n\n/**\n * @title BaseUpgradeabilityProxy\n * @dev This contract implements a proxy that allows to change the\n * implementation address to which it will delegate.\n * Such a change is called an implementation upgrade.\n */\ncontract BaseUpgradeabilityProxy is Proxy {\n  /**\n   * @dev Emitted when the implementation is upgraded.\n   * @param implementation Address of the new implementation.\n   */\n  event Upgraded(address indexed implementation);\n\n  /**\n   * @dev Storage slot with the address of the current implementation.\n   * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n   * validated in the constructor.\n   */\n  bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n  /**\n   * @dev Returns the current implementation.\n   * @return impl Address of the current implementation\n   */\n  function _implementation() internal view override returns (address impl) {\n    bytes32 slot = IMPLEMENTATION_SLOT;\n    assembly {\n      impl := sload(slot)\n    }\n  }\n\n  /**\n   * @dev Upgrades the proxy to a new implementation.\n   * @param newImplementation Address of the new implementation.\n   */\n  function _upgradeTo(address newImplementation) internal {\n    _setImplementation(newImplementation);\n    emit Upgraded(newImplementation);\n  }\n\n  /**\n   * @dev Sets the implementation address of the proxy.\n   * @param newImplementation Address of the new implementation.\n   */\n  function _setImplementation(address newImplementation) internal {\n    require(OpenZeppelinUpgradesAddress.isContract(newImplementation), \"Cannot set a proxy implementation to a non-contract address\");\n\n    bytes32 slot = IMPLEMENTATION_SLOT;\n\n    assembly {\n      sstore(slot, newImplementation)\n    }\n  }\n}"
    },
    "contracts/lib/@openzeppelin/upgrades/upgradeability/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @title Proxy\n * @dev Implements delegation of calls to other contracts, with proper\n * forwarding of return values and bubbling of failures.\n * It defines a fallback function that delegates all calls to the address\n * returned by the abstract _implementation() internal function.\n */\nabstract contract Proxy {\n  /**\n   * @dev Fallback function.\n   * Implemented entirely in `_fallback`.\n   */\n  fallback () payable external {\n    _fallback();\n  }\n\n  /**\n   * @return The Address of the implementation.\n   */\n  function _implementation() internal view virtual returns (address);\n\n  /**\n   * @dev Delegates execution to an implementation contract.\n   * This is a low level function that doesn't return to its internal call site.\n   * It will return to the external caller whatever the implementation returns.\n   * @param implementation Address to delegate.\n   */\n  function _delegate(address implementation) internal {\n    assembly {\n      // Copy msg.data. We take full control of memory in this inline assembly\n      // block because it will not return to Solidity code. We overwrite the\n      // Solidity scratch pad at memory position 0.\n      calldatacopy(0, 0, calldatasize())\n\n      // Call the implementation.\n      // out and outsize are 0 because we don't know the size yet.\n      let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n      // Copy the returned data.\n      returndatacopy(0, 0, returndatasize())\n\n      switch result\n      // delegatecall returns 0 on error.\n      case 0 { revert(0, returndatasize()) }\n      default { return(0, returndatasize()) }\n    }\n  }\n\n  /**\n   * @dev Function that is run as the first thing in the fallback function.\n   * Can be redefined in derived contracts to add functionality.\n   * Redefinitions must call super._willFallback().\n   */\n  function _willFallback() internal {\n  }\n\n  /**\n   * @dev fallback implementation.\n   * Extracted to enable manual triggering.\n   */\n  function _fallback() internal {\n    _willFallback();\n    _delegate(_implementation());\n  }\n}\n"
    },
    "contracts/lib/@openzeppelin/upgrades/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * Utility library of inline functions on addresses\n *\n * Source https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-solidity/v2.1.3/contracts/utils/Address.sol\n * This contract is copied here and renamed from the original to avoid clashes in the compiled artifacts\n * when the user imports a zos-lib contract (that transitively causes this contract to be compiled and added to the\n * build/artifacts folder) as well as the vanilla Address implementation from an openzeppelin version.\n */\nlibrary OpenZeppelinUpgradesAddress {\n    /**\n     * Returns whether the target address is a contract\n     * @dev This function will return false if invoked during the constructor of a contract,\n     * as the code is not actually created until after the constructor finishes.\n     * @param account address of the account to check\n     * @return whether the target address is a contract\n     */\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        // XXX Currently there is no better way to check if there is a contract in an address\n        // than to check the size of the code at that address.\n        // See https://ethereum.stackexchange.com/a/14016/36603\n        // for more details about how this works.\n        // TODO Check this again before the Serenity release, because all addresses will be\n        // contracts then.\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/math/MathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary MathUpgradeable {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow, so we distribute\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMathUpgradeable {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./IERC20Upgradeable.sol\";\nimport \"../../math/SafeMathUpgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20Upgradeable {\n    using SafeMathUpgradeable for uint256;\n    using AddressUpgradeable for address;\n\n    function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"./IERC20Upgradeable.sol\";\nimport \"../../math/SafeMathUpgradeable.sol\";\nimport \"../../proxy/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable {\n    using SafeMathUpgradeable for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal initializer {\n        __Context_init_unchained();\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal initializer {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal virtual {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n    uint256[44] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/lib/@harvest-finance/hardworkInterface/IStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\ninterface IStrategy {\n    \n    function unsalvagableTokens(address tokens) external view returns (bool);\n    \n    function underlying() external view returns (address);\n    function vault() external view returns (address);\n\n    function withdrawAllToVault() external;\n    function withdrawToVault(uint256 amount) external;\n\n    function investedUnderlyingBalance() external view returns (uint256); // itsNotMuch()\n\n    // should only be called by controller\n    function salvage(address recipient, address token, uint256 amount) external;\n\n    function doHardWork() external;\n    function depositArbCheck() external view returns(bool);\n}\n"
    },
    "contracts/lib/@harvest-finance/hardworkInterface/IStrategyV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\ninterface IStrategyV2 {\n\n    function unsalvagableTokens(address tokens) external view returns (bool);\n\n    // function governance() external view returns (address);\n    // function controller() external view returns (address);\n    // function underlying() external view returns (address);\n    // function vault() external view returns (address);\n\n    function withdrawAllToVault() external;\n    function withdrawToVault(uint256 correspondingShares, uint256 totalShares) external;\n\n    function investedUnderlyingBalance() external view returns (uint256); // itsNotMuch()\n\n    // should only be called by controller\n    function salvage(address recipient, address token, uint256 amount) external;\n\n    function doHardWork() external;\n    function depositArbCheck() external view returns(bool);\n}\n"
    },
    "contracts/lib/@harvest-finance/hardworkInterface/IVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\ninterface IVault {\n\n    function underlyingBalanceInVault() external view returns (uint256);\n    function underlyingBalanceWithInvestment() external view returns (uint256);\n\n    // function store() external view returns (address);\n    // function governance() external view returns (address);\n    // function controller() external view returns (address);\n    function underlying() external view returns (address);\n    function strategy() external view returns (address);\n\n    function setStrategy(address _strategy) external;\n    function setVaultFractionToInvest(uint256 numerator, uint256 denominator) external;\n\n    function deposit(uint256 amountWei) external;\n    function depositFor(uint256 amountWei, address holder) external;\n\n    function withdrawAll() external;\n    function withdraw(uint256 numberOfShares) external;\n    function getPricePerFullShare() external view returns (uint256);\n\n    function underlyingBalanceWithInvestmentForHolder(address holder) view external returns (uint256);\n\n    // hard work should be callable only by the controller (by the hard worker) or by governance\n    function doHardWork() external;\n}\n"
    },
    "contracts/lib/@harvest-finance/hardworkInterface/IController.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\ninterface IController {\n    // [Grey list]\n    // An EOA can safely interact with the system no matter what.\n    // If you're using Metamask, you're using an EOA.\n    // Only smart contracts may be affected by this grey list.\n    //\n    // This contract will not be able to ban any EOA from the system\n    // even if an EOA is being added to the greyList, he/she will still be able\n    // to interact with the whole system as if nothing happened.\n    // Only smart contracts will be affected by being added to the greyList.\n    // This grey list is only used in Vault.sol, see the code there for reference\n    function greyList(address _target) external view returns(bool);\n\n    function addVaultAndStrategy(address _vault, address _strategy) external;\n    function doHardWork(address _vault, uint256 hint, uint256 devianceNumerator, uint256 devianceDenominator) external;\n    function hasVault(address _vault) external returns(bool);\n\n    function salvage(address _token, uint256 amount) external;\n    function salvageStrategy(address _strategy, address _token, uint256 amount) external;\n\n    function notifyFee(address _underlying, uint256 fee) external;\n    function profitSharingNumerator() external view returns (uint256);\n    function profitSharingDenominator() external view returns (uint256);\n}\n"
    },
    "contracts/lib/@harvest-finance/ControllableInit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\nimport {GovernableInit} from \"./GovernableInit.sol\";\nimport {Storage} from \"./Storage.sol\";\n\n// A clone of Governable supporting the Initializable interface and pattern\ncontract ControllableInit is GovernableInit {\n\n  constructor() public {\n  }\n\n  function initialize(address _storage) public override initializer {\n    GovernableInit.initialize(_storage);\n  }\n\n  modifier onlyController() {\n    require(Storage(_storage()).isController(msg.sender), \"Not a controller\");\n    _;\n  }\n\n  modifier onlyControllerOrGovernance(){\n    require((Storage(_storage()).isController(msg.sender) || Storage(_storage()).isGovernance(msg.sender)),\n      \"The caller must be controller or governance\");\n    _;\n  }\n\n  function controller() public view returns (address) {\n    return Storage(_storage()).controller();\n  }\n}\n"
    },
    "contracts/lib/@harvest-finance/VaultStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\n\ncontract VaultStorage is Initializable {\n\n  bytes32 internal constant _STRATEGY_SLOT = 0xf1a169aa0f736c2813818fdfbdc5755c31e0839c8f49831a16543496b28574ea;\n  bytes32 internal constant _UNDERLYING_SLOT = 0x1994607607e11d53306ef62e45e3bd85762c58d9bf38b5578bc4a258a26a7371;\n  bytes32 internal constant _UNDERLYING_UNIT_SLOT = 0xa66bc57d4b4eed7c7687876ca77997588987307cb13ecc23f5e52725192e5fff;\n  bytes32 internal constant _VAULT_FRACTION_TO_INVEST_NUMERATOR_SLOT = 0x39122c9adfb653455d0c05043bd52fcfbc2be864e832efd3abc72ce5a3d7ed5a;\n  bytes32 internal constant _VAULT_FRACTION_TO_INVEST_DENOMINATOR_SLOT = 0x469a3bad2fab7b936c45eecd1f5da52af89cead3e2ed7f732b6f3fc92ed32308;\n  bytes32 internal constant _NEXT_IMPLEMENTATION_SLOT = 0xb1acf527cd7cd1668b30e5a9a1c0d845714604de29ce560150922c9d8c0937df;\n  bytes32 internal constant _NEXT_IMPLEMENTATION_TIMESTAMP_SLOT = 0x3bc747f4b148b37be485de3223c90b4468252967d2ea7f9fcbd8b6e653f434c9;\n  bytes32 internal constant _NEXT_IMPLEMENTATION_DELAY_SLOT = 0x82ddc3be3f0c1a6870327f78f4979a0b37b21b16736ef5be6a7a7a35e530bcf0;\n  bytes32 internal constant _STRATEGY_TIME_LOCK_SLOT = 0x6d02338b2e4c913c0f7d380e2798409838a48a2c4d57d52742a808c82d713d8b;\n  bytes32 internal constant _FUTURE_STRATEGY_SLOT = 0xb441b53a4e42c2ca9182bc7ede99bedba7a5d9360d9dfbd31fa8ee2dc8590610;\n  bytes32 internal constant _STRATEGY_UPDATE_TIME_SLOT = 0x56e7c0e75875c6497f0de657009613a32558904b5c10771a825cc330feff7e72;\n  bytes32 internal constant _ALLOW_SHARE_PRICE_DECREASE_SLOT = 0x22f7033891e85fc76735ebd320e0d3f546da431c4729c2f6d2613b11923aaaed;\n  bytes32 internal constant _WITHDRAW_BEFORE_REINVESTING_SLOT = 0x4215fbb95dc0890d3e1660fb9089350f2d3f350c0a756934874cae6febf42a79;\n\n  constructor() public {\n    assert(_STRATEGY_SLOT == bytes32(uint256(keccak256(\"eip1967.vaultStorage.strategy\")) - 1));\n    assert(_UNDERLYING_SLOT == bytes32(uint256(keccak256(\"eip1967.vaultStorage.underlying\")) - 1));\n    assert(_UNDERLYING_UNIT_SLOT == bytes32(uint256(keccak256(\"eip1967.vaultStorage.underlyingUnit\")) - 1));\n    assert(_VAULT_FRACTION_TO_INVEST_NUMERATOR_SLOT == bytes32(uint256(keccak256(\"eip1967.vaultStorage.vaultFractionToInvestNumerator\")) - 1));\n    assert(_VAULT_FRACTION_TO_INVEST_DENOMINATOR_SLOT == bytes32(uint256(keccak256(\"eip1967.vaultStorage.vaultFractionToInvestDenominator\")) - 1));\n    assert(_NEXT_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.vaultStorage.nextImplementation\")) - 1));\n    assert(_NEXT_IMPLEMENTATION_TIMESTAMP_SLOT == bytes32(uint256(keccak256(\"eip1967.vaultStorage.nextImplementationTimestamp\")) - 1));\n    assert(_NEXT_IMPLEMENTATION_DELAY_SLOT == bytes32(uint256(keccak256(\"eip1967.vaultStorage.nextImplementationDelay\")) - 1));\n    assert(_STRATEGY_TIME_LOCK_SLOT == bytes32(uint256(keccak256(\"eip1967.vaultStorage.strategyTimeLock\")) - 1));\n    assert(_FUTURE_STRATEGY_SLOT == bytes32(uint256(keccak256(\"eip1967.vaultStorage.futureStrategy\")) - 1));\n    assert(_STRATEGY_UPDATE_TIME_SLOT == bytes32(uint256(keccak256(\"eip1967.vaultStorage.strategyUpdateTime\")) - 1));\n    assert(_ALLOW_SHARE_PRICE_DECREASE_SLOT == bytes32(uint256(keccak256(\"eip1967.vaultStorage.allowSharePriceDecrease\")) - 1));\n    assert(_WITHDRAW_BEFORE_REINVESTING_SLOT == bytes32(uint256(keccak256(\"eip1967.vaultStorage.withdrawBeforeReinvesting\")) - 1));\n  }\n\n  function initialize(\n    address _underlying,\n    uint256 _toInvestNumerator,\n    uint256 _toInvestDenominator,\n    uint256 _underlyingUnit,\n    uint256 _implementationChangeDelay,\n    uint256 _strategyChangeDelay\n  ) public initializer {\n    _setUnderlying(_underlying);\n    _setVaultFractionToInvestNumerator(_toInvestNumerator);\n    _setVaultFractionToInvestDenominator(_toInvestDenominator);\n    _setUnderlyingUnit(_underlyingUnit);\n    _setNextImplementationDelay(_implementationChangeDelay);\n    _setStrategyTimeLock(_strategyChangeDelay);\n    _setStrategyUpdateTime(0);\n    _setFutureStrategy(address(0));\n    _setAllowSharePriceDecrease(false);\n    _setWithdrawBeforeReinvesting(false);\n  }\n\n  function _setStrategy(address _address) internal {\n    setAddress(_STRATEGY_SLOT, _address);\n  }\n\n  function _strategy() internal view returns (address) {\n    return getAddress(_STRATEGY_SLOT);\n  }\n\n  function _setUnderlying(address _address) internal {\n    setAddress(_UNDERLYING_SLOT, _address);\n  }\n\n  function _underlying() internal view returns (address) {\n    return getAddress(_UNDERLYING_SLOT);\n  }\n\n  function _setUnderlyingUnit(uint256 _value) internal {\n    setUint256(_UNDERLYING_UNIT_SLOT, _value);\n  }\n\n  function _underlyingUnit() internal view returns (uint256) {\n    return getUint256(_UNDERLYING_UNIT_SLOT);\n  }\n\n  function _setVaultFractionToInvestNumerator(uint256 _value) internal {\n    setUint256(_VAULT_FRACTION_TO_INVEST_NUMERATOR_SLOT, _value);\n  }\n\n  function _vaultFractionToInvestNumerator() internal view returns (uint256) {\n    return getUint256(_VAULT_FRACTION_TO_INVEST_NUMERATOR_SLOT);\n  }\n\n  function _setVaultFractionToInvestDenominator(uint256 _value) internal {\n    setUint256(_VAULT_FRACTION_TO_INVEST_DENOMINATOR_SLOT, _value);\n  }\n\n  function _vaultFractionToInvestDenominator() internal view returns (uint256) {\n    return getUint256(_VAULT_FRACTION_TO_INVEST_DENOMINATOR_SLOT);\n  }\n\n  function _setAllowSharePriceDecrease(bool _value) internal {\n    setBoolean(_ALLOW_SHARE_PRICE_DECREASE_SLOT, _value);\n  }\n\n  function _allowSharePriceDecrease() internal view returns (bool) {\n    return getBoolean(_ALLOW_SHARE_PRICE_DECREASE_SLOT);\n  }\n\n  function _setWithdrawBeforeReinvesting(bool _value) internal {\n    setBoolean(_WITHDRAW_BEFORE_REINVESTING_SLOT, _value);\n  }\n\n  function _withdrawBeforeReinvesting() internal view returns (bool) {\n    return getBoolean(_WITHDRAW_BEFORE_REINVESTING_SLOT);\n  }\n\n  function _setNextImplementation(address _address) internal {\n    setAddress(_NEXT_IMPLEMENTATION_SLOT, _address);\n  }\n\n  function _nextImplementation() internal view returns (address) {\n    return getAddress(_NEXT_IMPLEMENTATION_SLOT);\n  }\n\n  function _setNextImplementationTimestamp(uint256 _value) internal {\n    setUint256(_NEXT_IMPLEMENTATION_TIMESTAMP_SLOT, _value);\n  }\n\n  function _nextImplementationTimestamp() internal view returns (uint256) {\n    return getUint256(_NEXT_IMPLEMENTATION_TIMESTAMP_SLOT);\n  }\n\n  function _setNextImplementationDelay(uint256 _value) internal {\n    setUint256(_NEXT_IMPLEMENTATION_DELAY_SLOT, _value);\n  }\n\n  function _nextImplementationDelay() internal view returns (uint256) {\n    return getUint256(_NEXT_IMPLEMENTATION_DELAY_SLOT);\n  }\n\n  function _setStrategyTimeLock(uint256 _value) internal {\n    setUint256(_STRATEGY_TIME_LOCK_SLOT, _value);\n  }\n\n  function _strategyTimeLock() internal view returns (uint256) {\n    return getUint256(_STRATEGY_TIME_LOCK_SLOT);\n  }\n\n  function _setFutureStrategy(address _value) internal {\n    setAddress(_FUTURE_STRATEGY_SLOT, _value);\n  }\n\n  function _futureStrategy() internal view returns (address) {\n    return getAddress(_FUTURE_STRATEGY_SLOT);\n  }\n\n  function _setStrategyUpdateTime(uint256 _value) internal {\n    setUint256(_STRATEGY_UPDATE_TIME_SLOT, _value);\n  }\n\n  function _strategyUpdateTime() internal view returns (uint256) {\n    return getUint256(_STRATEGY_UPDATE_TIME_SLOT);\n  }\n\n  function setBoolean(bytes32 slot, bool _value) internal {\n    setUint256(slot, _value ? 1 : 0);\n  }\n\n  function getBoolean(bytes32 slot) internal view returns (bool) {\n    return (getUint256(slot) == 1);\n  }\n\n  function setAddress(bytes32 slot, address _address) private {\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      sstore(slot, _address)\n    }\n  }\n\n  function setUint256(bytes32 slot, uint256 _value) private {\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      sstore(slot, _value)\n    }\n  }\n\n  function getAddress(bytes32 slot) private view returns (address str) {\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      str := sload(slot)\n    }\n  }\n\n  function getUint256(bytes32 slot) private view returns (uint256 str) {\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      str := sload(slot)\n    }\n  }\n\n  uint256[50] private ______gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\nimport \"../proxy/Initializable.sol\";\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal initializer {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal initializer {\n    }\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// solhint-disable-next-line compiler-version\npragma solidity >=0.4.24 <0.8.0;\n\nimport \"../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || _isConstructor() || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /// @dev Returns true if and only if the function is running in the constructor\n    function _isConstructor() private view returns (bool) {\n        return !AddressUpgradeable.isContract(address(this));\n    }\n}\n"
    },
    "contracts/lib/@harvest-finance/GovernableInit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\nimport {Storage} from \"./Storage.sol\";\n\n// A clone of Governable supporting the Initializable interface and pattern\ncontract GovernableInit is Initializable {\n\n  bytes32 internal constant _STORAGE_SLOT = 0xa7ec62784904ff31cbcc32d09932a58e7f1e4476e1d041995b37c917990b16dc;\n\n  modifier onlyGovernance() {\n    require(Storage(_storage()).isGovernance(msg.sender), \"Not governance\");\n    _;\n  }\n\n  constructor() public {\n    assert(_STORAGE_SLOT == bytes32(uint256(keccak256(\"eip1967.governableInit.storage\")) - 1));\n  }\n\n  function initialize(address _store) public virtual initializer {\n    _setStorage(_store);\n  }\n\n  function _setStorage(address newStorage) private {\n    bytes32 slot = _STORAGE_SLOT;\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      sstore(slot, newStorage)\n    }\n  }\n\n  function setStorage(address _store) public onlyGovernance {\n    require(_store != address(0), \"new storage shouldn't be empty\");\n    _setStorage(_store);\n  }\n\n  function _storage() internal view returns (address str) {\n    bytes32 slot = _STORAGE_SLOT;\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      str := sload(slot)\n    }\n  }\n\n  function governance() public view returns (address) {\n    return Storage(_storage()).governance();\n  }\n}\n"
    },
    "contracts/lib/@harvest-finance/strategies/upgradability/BaseUpgradeableStrategyStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\n\ncontract BaseUpgradeableStrategyStorage {\n\n  bytes32 internal constant _UNDERLYING_SLOT = 0xa1709211eeccf8f4ad5b6700d52a1a9525b5f5ae1e9e5f9e5a0c2fc23c86e530;\n  bytes32 internal constant _VAULT_SLOT = 0xefd7c7d9ef1040fc87e7ad11fe15f86e1d11e1df03c6d7c87f7e1f4041f08d41;\n\n  bytes32 internal constant _REWARD_TOKEN_SLOT = 0xdae0aafd977983cb1e78d8f638900ff361dc3c48c43118ca1dd77d1af3f47bbf;\n  bytes32 internal constant _REWARD_POOL_SLOT = 0x3d9bb16e77837e25cada0cf894835418b38e8e18fbec6cfd192eb344bebfa6b8;\n  bytes32 internal constant _SELL_FLOOR_SLOT = 0xc403216a7704d160f6a3b5c3b149a1226a6080f0a5dd27b27d9ba9c022fa0afc;\n  bytes32 internal constant _SELL_SLOT = 0x656de32df98753b07482576beb0d00a6b949ebf84c066c765f54f26725221bb6;\n  bytes32 internal constant _PAUSED_INVESTING_SLOT = 0xa07a20a2d463a602c2b891eb35f244624d9068572811f63d0e094072fb54591a;\n\n  bytes32 internal constant _PROFIT_SHARING_NUMERATOR_SLOT = 0xe3ee74fb7893020b457d8071ed1ef76ace2bf4903abd7b24d3ce312e9c72c029;\n  bytes32 internal constant _PROFIT_SHARING_DENOMINATOR_SLOT = 0x0286fd414602b432a8c80a0125e9a25de9bba96da9d5068c832ff73f09208a3b;\n\n  bytes32 internal constant _NEXT_IMPLEMENTATION_SLOT = 0x29f7fcd4fe2517c1963807a1ec27b0e45e67c60a874d5eeac7a0b1ab1bb84447;\n  bytes32 internal constant _NEXT_IMPLEMENTATION_TIMESTAMP_SLOT = 0x414c5263b05428f1be1bfa98e25407cc78dd031d0d3cd2a2e3d63b488804f22e;\n  bytes32 internal constant _NEXT_IMPLEMENTATION_DELAY_SLOT = 0x82b330ca72bcd6db11a26f10ce47ebcfe574a9c646bccbc6f1cd4478eae16b31;\n\n  constructor() public {\n    assert(_UNDERLYING_SLOT == bytes32(uint256(keccak256(\"eip1967.strategyStorage.underlying\")) - 1));\n    assert(_VAULT_SLOT == bytes32(uint256(keccak256(\"eip1967.strategyStorage.vault\")) - 1));\n    assert(_REWARD_TOKEN_SLOT == bytes32(uint256(keccak256(\"eip1967.strategyStorage.rewardToken\")) - 1));\n    assert(_REWARD_POOL_SLOT == bytes32(uint256(keccak256(\"eip1967.strategyStorage.rewardPool\")) - 1));\n    assert(_SELL_FLOOR_SLOT == bytes32(uint256(keccak256(\"eip1967.strategyStorage.sellFloor\")) - 1));\n    assert(_SELL_SLOT == bytes32(uint256(keccak256(\"eip1967.strategyStorage.sell\")) - 1));\n    assert(_PAUSED_INVESTING_SLOT == bytes32(uint256(keccak256(\"eip1967.strategyStorage.pausedInvesting\")) - 1));\n\n    assert(_PROFIT_SHARING_NUMERATOR_SLOT == bytes32(uint256(keccak256(\"eip1967.strategyStorage.profitSharingNumerator\")) - 1));\n    assert(_PROFIT_SHARING_DENOMINATOR_SLOT == bytes32(uint256(keccak256(\"eip1967.strategyStorage.profitSharingDenominator\")) - 1));\n\n    assert(_NEXT_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.strategyStorage.nextImplementation\")) - 1));\n    assert(_NEXT_IMPLEMENTATION_TIMESTAMP_SLOT == bytes32(uint256(keccak256(\"eip1967.strategyStorage.nextImplementationTimestamp\")) - 1));\n    assert(_NEXT_IMPLEMENTATION_DELAY_SLOT == bytes32(uint256(keccak256(\"eip1967.strategyStorage.nextImplementationDelay\")) - 1));\n  }\n\n  function _setUnderlying(address _address) internal {\n    setAddress(_UNDERLYING_SLOT, _address);\n  }\n\n  function underlying() public view returns (address) {\n    return getAddress(_UNDERLYING_SLOT);\n  }\n\n  function _setRewardPool(address _address) internal {\n    setAddress(_REWARD_POOL_SLOT, _address);\n  }\n\n  function rewardPool() public view returns (address) {\n    return getAddress(_REWARD_POOL_SLOT);\n  }\n\n  function _setRewardToken(address _address) internal {\n    setAddress(_REWARD_TOKEN_SLOT, _address);\n  }\n\n  function rewardToken() public view returns (address) {\n    return getAddress(_REWARD_TOKEN_SLOT);\n  }\n\n  function _setVault(address _address) internal {\n    setAddress(_VAULT_SLOT, _address);\n  }\n\n  function vault() public view returns (address) {\n    return getAddress(_VAULT_SLOT);\n  }\n\n  // a flag for disabling selling for simplified emergency exit\n  function _setSell(bool _value) internal {\n    setBoolean(_SELL_SLOT, _value);\n  }\n\n  function sell() public view returns (bool) {\n    return getBoolean(_SELL_SLOT);\n  }\n\n  function _setPausedInvesting(bool _value) internal {\n    setBoolean(_PAUSED_INVESTING_SLOT, _value);\n  }\n\n  function pausedInvesting() public view returns (bool) {\n    return getBoolean(_PAUSED_INVESTING_SLOT);\n  }\n\n  function _setSellFloor(uint256 _value) internal {\n    setUint256(_SELL_FLOOR_SLOT, _value);\n  }\n\n  function sellFloor() public view returns (uint256) {\n    return getUint256(_SELL_FLOOR_SLOT);\n  }\n\n  function _setProfitSharingNumerator(uint256 _value) internal {\n    setUint256(_PROFIT_SHARING_NUMERATOR_SLOT, _value);\n  }\n\n  function profitSharingNumerator() public view returns (uint256) {\n    return getUint256(_PROFIT_SHARING_NUMERATOR_SLOT);\n  }\n\n  function _setProfitSharingDenominator(uint256 _value) internal {\n    setUint256(_PROFIT_SHARING_DENOMINATOR_SLOT, _value);\n  }\n\n  function profitSharingDenominator() public view returns (uint256) {\n    return getUint256(_PROFIT_SHARING_DENOMINATOR_SLOT);\n  }\n\n  // upgradeability\n\n  function _setNextImplementation(address _address) internal {\n    setAddress(_NEXT_IMPLEMENTATION_SLOT, _address);\n  }\n\n  function nextImplementation() public view returns (address) {\n    return getAddress(_NEXT_IMPLEMENTATION_SLOT);\n  }\n\n  function _setNextImplementationTimestamp(uint256 _value) internal {\n    setUint256(_NEXT_IMPLEMENTATION_TIMESTAMP_SLOT, _value);\n  }\n\n  function nextImplementationTimestamp() public view returns (uint256) {\n    return getUint256(_NEXT_IMPLEMENTATION_TIMESTAMP_SLOT);\n  }\n\n  function _setNextImplementationDelay(uint256 _value) internal {\n    setUint256(_NEXT_IMPLEMENTATION_DELAY_SLOT, _value);\n  }\n\n  function nextImplementationDelay() public view returns (uint256) {\n    return getUint256(_NEXT_IMPLEMENTATION_DELAY_SLOT);\n  }\n\n  function setBoolean(bytes32 slot, bool _value) internal {\n    setUint256(slot, _value ? 1 : 0);\n  }\n\n  function getBoolean(bytes32 slot) internal view returns (bool) {\n    return (getUint256(slot) == 1);\n  }\n\n  function setAddress(bytes32 slot, address _address) internal {\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      sstore(slot, _address)\n    }\n  }\n\n  function setUint256(bytes32 slot, uint256 _value) internal {\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      sstore(slot, _value)\n    }\n  }\n\n  function getAddress(bytes32 slot) internal view returns (address str) {\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      str := sload(slot)\n    }\n  }\n\n  function getUint256(bytes32 slot) internal view returns (uint256 str) {\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      str := sload(slot)\n    }\n  }\n}\n"
    },
    "contracts/lib/@harvest-finance/strategies/upgradability/BaseUpgradeableStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\nimport {BaseUpgradeableStrategyStorage} from \"./BaseUpgradeableStrategyStorage.sol\";\nimport {ControllableInit} from \"../../ControllableInit.sol\";\nimport {IController} from \"../../hardworkInterface/IController.sol\";\nimport {IBEP20} from \"@pancakeswap/pancake-swap-lib/contracts/token/BEP20/IBEP20.sol\";\nimport {SafeMath} from \"@pancakeswap/pancake-swap-lib/contracts/math/SafeMath.sol\";\nimport {SafeBEP20} from \"@pancakeswap/pancake-swap-lib/contracts/token/BEP20/SafeBEP20.sol\";\n\ncontract BaseUpgradeableStrategy is Initializable, ControllableInit, BaseUpgradeableStrategyStorage {\n  using SafeMath for uint256;\n  using SafeBEP20 for IBEP20;\n\n  event ProfitsNotCollected(bool sell, bool floor);\n  event ProfitLogInReward(uint256 profitAmount, uint256 feeAmount, uint256 timestamp);\n\n  modifier restricted() {\n    require(msg.sender == vault() || msg.sender == controller()\n      || msg.sender == governance(),\n      \"The sender has to be the controller, governance, or vault\");\n    _;\n  }\n\n  // This is only used in `investAllUnderlying()`\n  // The user can still freely withdraw from the strategy\n  modifier onlyNotPausedInvesting() {\n    require(!pausedInvesting(), \"Action blocked as the strategy is in emergency state\");\n    _;\n  }\n\n  constructor() public BaseUpgradeableStrategyStorage() {\n  }\n\n  function initialize(\n    address _storage,\n    address _underlying,\n    address _vault,\n    address _rewardPool,\n    address _rewardToken,\n    uint256 _profitSharingNumerator,\n    uint256 _profitSharingDenominator,\n    bool _sell,\n    uint256 _sellFloor,\n    uint256 _implementationChangeDelay\n  ) public initializer {\n    ControllableInit.initialize(\n      _storage\n    );\n    _setUnderlying(_underlying);\n    _setVault(_vault);\n    _setRewardPool(_rewardPool);\n    _setRewardToken(_rewardToken);\n    _setProfitSharingNumerator(_profitSharingNumerator);\n    _setProfitSharingDenominator(_profitSharingDenominator);\n\n    _setSell(_sell);\n    _setSellFloor(_sellFloor);\n    _setNextImplementationDelay(_implementationChangeDelay);\n    _setPausedInvesting(false);\n  }\n\n  /**\n  * Schedules an upgrade for this vault's proxy.\n  */\n  function scheduleUpgrade(address impl) public onlyGovernance {\n    _setNextImplementation(impl);\n    _setNextImplementationTimestamp(block.timestamp.add(nextImplementationDelay()));\n  }\n\n  function _finalizeUpgrade() internal {\n    _setNextImplementation(address(0));\n    _setNextImplementationTimestamp(0);\n  }\n\n  function shouldUpgrade() external view returns (bool, address) {\n    return (\n      nextImplementationTimestamp() != 0\n        && block.timestamp > nextImplementationTimestamp()\n        && nextImplementation() != address(0),\n      nextImplementation()\n    );\n  }\n\n  // reward notification\n\n  function notifyProfitInRewardToken(uint256 _rewardBalance) internal {\n    if( _rewardBalance > 0 ){\n      uint256 feeAmount = _rewardBalance.mul(profitSharingNumerator()).div(profitSharingDenominator());\n      emit ProfitLogInReward(_rewardBalance, feeAmount, block.timestamp);\n      IBEP20(rewardToken()).safeApprove(controller(), 0);\n      IBEP20(rewardToken()).safeApprove(controller(), feeAmount);\n\n      IController(controller()).notifyFee(\n        rewardToken(),\n        feeAmount\n      );\n    } else {\n      emit ProfitLogInReward(0, 0, block.timestamp);\n    }\n  }\n}\n"
    },
    "@pancakeswap/pancake-swap-lib/contracts/token/BEP20/IBEP20.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.4.0;\n\ninterface IBEP20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the token decimals.\n     */\n    function decimals() external view returns (uint8);\n\n    /**\n     * @dev Returns the token symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the token name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the bep token owner.\n     */\n    function getOwner() external view returns (address);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address _owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@pancakeswap/pancake-swap-lib/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.4.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, 'SafeMath: addition overflow');\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, 'SafeMath: subtraction overflow');\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, 'SafeMath: multiplication overflow');\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, 'SafeMath: division by zero');\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, 'SafeMath: modulo by zero');\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = x < y ? x : y;\n    }\n\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\n        if (y > 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n}\n"
    },
    "@pancakeswap/pancake-swap-lib/contracts/token/BEP20/SafeBEP20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport './IBEP20.sol';\nimport '../../math/SafeMath.sol';\nimport '../../utils/Address.sol';\n\n/**\n * @title SafeBEP20\n * @dev Wrappers around BEP20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeBEP20 for IBEP20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeBEP20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(\n        IBEP20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IBEP20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IBEP20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IBEP20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            'SafeBEP20: approve from non-zero to non-zero allowance'\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IBEP20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IBEP20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(\n            value,\n            'SafeBEP20: decreased allowance below zero'\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IBEP20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, 'SafeBEP20: low-level call failed');\n        if (returndata.length > 0) {\n            // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), 'SafeBEP20: BEP20 operation did not succeed');\n        }\n    }\n}\n"
    },
    "@pancakeswap/pancake-swap-lib/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            codehash := extcodehash(account)\n        }\n        return (codehash != accountHash && codehash != 0x0);\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, 'Address: insufficient balance');\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{value: amount}('');\n        require(success, 'Address: unable to send value, recipient may have reverted');\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, 'Address: low-level call failed');\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, 'Address: low-level call with value failed');\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, 'Address: insufficient balance for call');\n        return _functionCallWithValue(target, data, value, errorMessage);\n    }\n\n    function _functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 weiValue,\n        string memory errorMessage\n    ) private returns (bytes memory) {\n        require(isContract(target), 'Address: call to non-contract');\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{value: weiValue}(data);\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/strategies/pancakeswap/PancakeMasterChefLPStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\nimport \"./IMasterChef.sol\";\nimport \"../../lib/@harvest-finance/hardworkInterface/IStrategyV2.sol\";\nimport \"@pancakeswap/pancake-swap-lib/contracts/math/SafeMath.sol\";\n// import \"@openzeppelin/contracts/token/ERC20/ERC20Detailed.sol\";\nimport \"@pancakeswap/pancake-swap-lib/contracts/token/BEP20/IBEP20.sol\";\nimport \"@pancakeswap/pancake-swap-lib/contracts/token/BEP20/SafeBEP20.sol\";\nimport \"../../lib/@harvest-finance/hardworkInterface/IStrategy.sol\";\nimport \"../../lib/@harvest-finance/hardworkInterface/IVault.sol\";\nimport \"../../lib/@harvest-finance/strategies/upgradability/BaseUpgradeableStrategy.sol\";\nimport \"@pancakeswap-libs/pancake-swap-core/contracts/interfaces/IPancakePair.sol\";\nimport \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\";\n\ncontract PancakeMasterChefLPStrategy is IStrategyV2, BaseUpgradeableStrategy {\n  using SafeMath for uint256;\n  using SafeBEP20 for IBEP20;\n\n  address constant public pancakeswapRouterV2 = address(0x05fF2B0DB69458A0750badebc4f9e13aDd608C7F);\n  \n  // additional storage slots (on top of BaseUpgradeableStrategy ones) are defined here\n  bytes32 internal constant _POOLID_SLOT = 0x3fd729bfa2e28b7806b03a6e014729f59477b530f995be4d51defc9dad94810b;\n  // this would be reset on each upgrade\n  mapping (address => address[]) public pancakeswapRoutes;\n\n  constructor() public BaseUpgradeableStrategy() {\n    assert(_POOLID_SLOT == bytes32(uint256(keccak256(\"eip1967.strategyStorage.poolId\")) - 1));\n  }\n\n  function initializeStrategy(\n    address _storage,\n    address _underlying,\n    address _vault,\n    address _rewardPool,\n    address _rewardToken,\n    uint256 _poolID\n  ) public initializer {\n\n    BaseUpgradeableStrategy.initialize(\n      _storage,\n      _underlying,\n      _vault,\n      _rewardPool,\n      _rewardToken,\n      300, // profit sharing numerator\n      1000, // profit sharing denominator\n      true, // sell\n      1e18, // sell floor\n      12 hours // implementation change delay\n    );\n\n    address _lpt;\n    (_lpt,,,) = IMasterChef(rewardPool()).poolInfo(_poolID);\n    require(_lpt == underlying(), \"Pool Info does not match underlying\");\n    _setPoolId(_poolID);\n\n    address uniLPComponentToken0 = IPancakePair(underlying()).token0();\n    address uniLPComponentToken1 = IPancakePair(underlying()).token1();\n\n    // these would be required to be initialized separately by governance\n    pancakeswapRoutes[uniLPComponentToken0] = new address[](0);\n    pancakeswapRoutes[uniLPComponentToken1] = new address[](0);\n  }\n\n  function depositArbCheck() public view override returns(bool) {\n    return true;\n  }\n\n  function rewardPoolBalance() internal view returns (uint256 bal) {\n      (bal,) = IMasterChef(rewardPool()).userInfo(poolId(), address(this));\n  }\n\n  function exitRewardPool() internal {\n      uint256 bal = rewardPoolBalance();\n      if (bal != 0) {\n          IMasterChef(rewardPool()).withdraw(poolId(), bal);\n      }\n  }\n\n  function unsalvagableTokens(address token) public view override returns (bool) {\n    return (token == rewardToken() || token == underlying());\n  }\n\n  function enterRewardPool() internal {\n    uint256 entireBalance = IBEP20(underlying()).balanceOf(address(this));\n    IBEP20(underlying()).safeApprove(rewardPool(), 0);\n    IBEP20(underlying()).safeApprove(rewardPool(), entireBalance);\n    IMasterChef(rewardPool()).deposit(poolId(), entireBalance);\n  }\n\n  /*\n  *   In case there are some issues discovered about the pool or underlying asset\n  *   Governance can exit the pool properly\n  *   The function is only used for emergency to exit the pool\n  */\n  function emergencyExit() public onlyGovernance {\n    exitRewardPool();\n    _setPausedInvesting(true);\n  }\n\n  /*\n  *   Resumes the ability to invest into the underlying reward pools\n  */\n\n  function continueInvesting() public onlyGovernance {\n    _setPausedInvesting(false);\n  }\n\n  function setLiquidationPathsOnPancake(address [] memory _uniswapRouteToToken0, address [] memory _uniswapRouteToToken1) public onlyGovernance {\n    address uniLPComponentToken0 = IPancakePair(underlying()).token0();\n    address uniLPComponentToken1 = IPancakePair(underlying()).token1();\n    pancakeswapRoutes[uniLPComponentToken0] = _uniswapRouteToToken0;\n    pancakeswapRoutes[uniLPComponentToken1] = _uniswapRouteToToken1;\n  }\n\n  // We assume that all the tradings can be done on Uniswap\n  function _liquidateReward() internal {\n    uint256 rewardBalance = IBEP20(rewardToken()).balanceOf(address(this));\n    if (!sell() || rewardBalance < sellFloor()) {\n      // Profits can be disabled for possible simplified and rapid exit\n      emit ProfitsNotCollected(sell(), rewardBalance < sellFloor());\n      return;\n    }\n\n    notifyProfitInRewardToken(rewardBalance);\n    uint256 remainingRewardBalance = IBEP20(rewardToken()).balanceOf(address(this));\n\n    address uniLPComponentToken0 = IPancakePair(underlying()).token0();\n    address uniLPComponentToken1 = IPancakePair(underlying()).token1();\n\n    address[] memory routesToken0 = pancakeswapRoutes[address(uniLPComponentToken0)];\n    address[] memory routesToken1 = pancakeswapRoutes[address(uniLPComponentToken1)];\n\n    if (remainingRewardBalance > 0 // we have tokens to swap\n      && routesToken0.length > 1 // and we have a route to do the swap\n      && routesToken1.length > 1 // and we have a route to do the swap\n    ) {\n      uint256 amountOutMin = 1;\n\n      // allow PancakeSwap to sell our reward\n      IBEP20(rewardToken()).safeApprove(pancakeswapRouterV2, 0);\n      IBEP20(rewardToken()).safeApprove(pancakeswapRouterV2, remainingRewardBalance);\n\n      uint256 toToken0 = remainingRewardBalance / 2;\n      uint256 toToken1 = remainingRewardBalance.sub(toToken0);\n\n      // we sell to uni\n\n      // sell Uni to token1\n      // we can accept 1 as minimum because this is called only by a trusted role\n      IUniswapV2Router02(pancakeswapRouterV2).swapExactTokensForTokens(\n        toToken0,\n        amountOutMin,\n        routesToken0,\n        address(this),\n        block.timestamp\n      );\n      uint256 token0Amount = IBEP20(uniLPComponentToken0).balanceOf(address(this));\n\n      // sell Uni to token2\n      // we can accept 1 as minimum because this is called only by a trusted role\n      IUniswapV2Router02(pancakeswapRouterV2).swapExactTokensForTokens(\n        toToken1,\n        amountOutMin,\n        routesToken1,\n        address(this),\n        block.timestamp\n      );\n      uint256 token1Amount = IBEP20(uniLPComponentToken1).balanceOf(address(this));\n\n      // provide token1 and token2 to SUSHI\n      IBEP20(uniLPComponentToken0).safeApprove(pancakeswapRouterV2, 0);\n      IBEP20(uniLPComponentToken0).safeApprove(pancakeswapRouterV2, token0Amount);\n\n      IBEP20(uniLPComponentToken1).safeApprove(pancakeswapRouterV2, 0);\n      IBEP20(uniLPComponentToken1).safeApprove(pancakeswapRouterV2, token1Amount);\n\n      // we provide liquidity to sushi\n      uint256 liquidity;\n      (,,liquidity) = IUniswapV2Router02(pancakeswapRouterV2).addLiquidity(\n        uniLPComponentToken0,\n        uniLPComponentToken1,\n        token0Amount,\n        token1Amount,\n        1,  // we are willing to take whatever the pair gives us\n        1,  // we are willing to take whatever the pair gives us\n        address(this),\n        block.timestamp\n      );\n    }\n  }\n\n  /*\n  *   Stakes everything the strategy holds into the reward pool\n  */\n  function investAllUnderlying() internal onlyNotPausedInvesting {\n    // this check is needed, because most of the SNX reward pools will revert if\n    // you try to stake(0).\n    if(IBEP20(underlying()).balanceOf(address(this)) > 0) {\n      enterRewardPool();\n    }\n  }\n\n  /*\n  *   Withdraws all the asset to the vault\n  */\n  function withdrawAllToVault() public override restricted {\n    if (address(rewardPool()) != address(0)) {\n      exitRewardPool();\n    }\n    _liquidateReward();\n    IBEP20(underlying()).safeTransfer(vault(), IBEP20(underlying()).balanceOf(address(this)));\n  }\n\n  /*\n  *   Withdraws all the asset to the vault\n  */\n  function withdrawToVault(uint256 amount) public restricted {\n    // Typically there wouldn't be any amount here\n    // however, it is possible because of the emergencyExit\n    uint256 entireBalance = IBEP20(underlying()).balanceOf(address(this));\n\n    if(amount > entireBalance){\n      // While we have the check above, we still using SafeMath below\n      // for the peace of mind (in case something gets changed in between)\n      uint256 needToWithdraw = amount.sub(entireBalance);\n      uint256 toWithdraw = SafeMath.min(rewardPoolBalance(), needToWithdraw);\n      IMasterChef(rewardPool()).withdraw(poolId(), toWithdraw);\n    }\n\n    IBEP20(underlying()).safeTransfer(vault(), amount);\n  }\n\n  function withdrawToVault(uint256 correspondingShares, uint256 totalShares)  public override restricted {\n\n  }\n\n  /*\n  *   Note that we currently do not have a mechanism here to include the\n  *   amount of reward that is accrued.\n  */\n  function investedUnderlyingBalance() external view override returns (uint256) {\n    if (rewardPool() == address(0)) {\n      return IBEP20(underlying()).balanceOf(address(this));\n    }\n    // Adding the amount locked in the reward pool and the amount that is somehow in this contract\n    // both are in the units of \"underlying\"\n    // The second part is needed because there is the emergency exit mechanism\n    // which would break the assumption that all the funds are always inside of the reward pool\n    return rewardPoolBalance().add(IBEP20(underlying()).balanceOf(address(this)));\n  }\n\n  /*\n  *   Governance or Controller can claim coins that are somehow transferred into the contract\n  *   Note that they cannot come in take away coins that are used and defined in the strategy itself\n  */\n  function salvage(address recipient, address token, uint256 amount) external override onlyControllerOrGovernance {\n     // To make sure that governance cannot come in and take away the coins\n    require(!unsalvagableTokens(token), \"token is defined as not salvagable\");\n    IBEP20(token).safeTransfer(recipient, amount);\n  }\n\n  /*\n  *   Get the reward, sell it in exchange for underlying, invest what you got.\n  *   It's not much, but it's honest work.\n  *\n  *   Note that although `onlyNotPausedInvesting` is not added here,\n  *   calling `investAllUnderlying()` affectively blocks the usage of `doHardWork`\n  *   when the investing is being paused by governance.\n  */\n  function doHardWork() external override onlyNotPausedInvesting restricted {\n    exitRewardPool();\n    _liquidateReward();\n    investAllUnderlying();\n  }\n\n  /**\n  * Can completely disable claiming UNI rewards and selling. Good for emergency withdraw in the\n  * simplest possible way.\n  */\n  function setSell(bool s) public onlyGovernance {\n    _setSell(s);\n  }\n\n  /**\n  * Sets the minimum amount of CRV needed to trigger a sale.\n  */\n  function setSellFloor(uint256 floor) public onlyGovernance {\n    _setSellFloor(floor);\n  }\n\n  // masterchef rewards pool ID\n  function _setPoolId(uint256 _value) internal {\n    setUint256(_POOLID_SLOT, _value);\n  }\n\n  function poolId() public view returns (uint256) {\n    return getUint256(_POOLID_SLOT);\n  }\n\n  function finalizeUpgrade() external onlyGovernance {\n    _finalizeUpgrade();\n    // reset the liquidation paths\n    // they need to be re-set manually\n    address uniLPComponentToken0 = IPancakePair(underlying()).token0();\n    address uniLPComponentToken1 = IPancakePair(underlying()).token1();\n\n    // these would be required to be initialized separately by governance\n    pancakeswapRoutes[uniLPComponentToken0] = new address[](0);\n    pancakeswapRoutes[uniLPComponentToken1] = new address[](0);\n  }\n}"
    },
    "contracts/strategies/pancakeswap/IMasterChef.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\ninterface IMasterChef {\n    function deposit(uint256 _pid, uint256 _amount) external;\n    function withdraw(uint256 _pid, uint256 _amount) external;\n    function userInfo(uint256 _pid, address _user) external view returns (uint256 amount, uint256 rewardDebt);\n    function poolInfo(uint256 _pid) external view returns (address lpToken, uint256, uint256, uint256);\n    function massUpdatePools() external;\n    function pendingSushi(uint256 _pid, address _user) external view returns (uint256 amount);\n    // interface reused for pickle\n    function pendingPickle(uint256 _pid, address _user) external view returns (uint256 amount);\n}\n"
    },
    "@pancakeswap-libs/pancake-swap-core/contracts/interfaces/IPancakePair.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IPancakePair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
    },
    "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol": {
      "content": "pragma solidity >=0.6.2;\n\nimport './IUniswapV2Router01.sol';\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n"
    },
    "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol": {
      "content": "pragma solidity >=0.6.2;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n"
    },
    "contracts/lib/@harvest-finance/FeeRewardForwarder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\nimport \"./Governable.sol\";\nimport \"./hardworkInterface/IRewardPool.sol\";\nimport \"@pancakeswap/pancake-swap-lib/contracts/token/BEP20/SafeBEP20.sol\";\nimport \"@pancakeswap/pancake-swap-lib/contracts/token/BEP20/IBEP20.sol\";\nimport \"@pancakeswap/pancake-swap-lib/contracts/math/SafeMath.sol\";\nimport \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\";\n\n\n// FeeRewardForwarder with no grain config\ncontract FeeRewardForwarder is Governable {\n  using SafeBEP20 for IBEP20;\n  using SafeMath for uint256;\n\n  address public farm;\n\n  // stables\n  address constant public usdt = address(0x55d398326f99059fF775485246999027B3197955);\n  address constant public vai = address(0x4BD17003473389A42DAF6a0a729f6Fdb328BbBd7);\n\n  // yield farming\n  address constant public cake = address(0x0E09FaBB73Bd3Ade0a17ECC321fD13a19e81cE82);\n  address constant public xvs = address(0xcF6BB5389c92Bdda8a3747Ddb454cB7a64626C63);\n\n  // wbnb\n  address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n\n  mapping (address => mapping (address => address[])) public pancakeswapRoutes;\n  \n  // the targeted reward token to convert everything to\n  address public targetToken;\n  address public profitSharingPool;\n\n  address constant public pancakeswapRouterV2 = address(0x05fF2B0DB69458A0750badebc4f9e13aDd608C7F);\n\n  event TokenPoolSet(address token, address pool);\n\n  constructor(address _storage, address _farm) public Governable(_storage) {\n    require(_farm != address(0), \"_farm not defined\");\n    farm = _farm;\n\n    pancakeswapRoutes[cake][wbnb] = [cake, wbnb];\n    pancakeswapRoutes[xvs][wbnb] = [xvs, wbnb];\n    \n    // // Route to grain is always to farm then to grain.\n    // // So we will just use the existing route to buy FARM first\n    // // then sell partially to grain.\n    // pancakeswapRoutes[grain][farm] = [grain, farm];\n    // pancakeswapRoutes[farm][grain] = [farm, grain];\n\n    // // preset for grainBacker (usdc or weth)\n    // //weth\n    // pancakeswapRoutes[dai][weth] = [dai, weth];\n    // pancakeswapRoutes[usdc][weth] = [usdc, weth];\n    // pancakeswapRoutes[usdt][weth] = [usdt, weth];\n\n    // pancakeswapRoutes[wbtc][weth] = [wbtc, weth];\n    // pancakeswapRoutes[renBTC][weth] = [renBTC, weth];\n    // pancakeswapRoutes[sushi][weth] = [sushi, weth];\n    // pancakeswapRoutes[dego][weth] = [dego, weth];\n    // pancakeswapRoutes[crv][weth] = [crv, weth];\n    // pancakeswapRoutes[comp][weth] = [comp, weth];\n\n    // // usdc\n    // pancakeswapRoutes[weth][usdc] = [weth, usdc];\n    // pancakeswapRoutes[dai][usdc] = [dai, weth, usdc];\n    // pancakeswapRoutes[usdt][usdc] = [usdt, weth, usdc];\n\n    // pancakeswapRoutes[wbtc][usdc] = [wbtc, weth, usdc];\n    // pancakeswapRoutes[renBTC][usdc] = [renBTC, weth, usdc];\n    // pancakeswapRoutes[sushi][usdc] = [sushi, weth, usdc];\n    // pancakeswapRoutes[dego][usdc] = [dego, weth, usdc];\n    // pancakeswapRoutes[crv][usdc] = [crv, weth, usdc];\n    // pancakeswapRoutes[comp][usdc] = [comp, weth, usdc];\n  }\n\n  /*\n  *   Set the pool that will receive the reward token\n  *   based on the address of the reward Token\n  */\n  function setTokenPool(address _pool) public onlyGovernance {\n    require(wbnb == IRewardPool(_pool).rewardToken(), \"Rewardpool's token is not WBNB\");\n    profitSharingPool = _pool;\n    targetToken = wbnb;\n    emit TokenPoolSet(targetToken, _pool);\n  }\n\n  /**\n  * Sets the path for swapping tokens to the to address\n  * The to address is not validated to match the targetToken,\n  * so that we could first update the paths, and then,\n  * set the new target\n  */\n  function setConversionPath(address from, address to, address[] memory _pancakeswapRoute)\n    public \n    onlyGovernance \n  {\n    require(\n      from == _pancakeswapRoute[0],\n      \"The first token of the Pancakeswap route must be the from token\"\n    );\n    require(\n      to == _pancakeswapRoute[_pancakeswapRoute.length - 1],\n      \"The last token of the Pancakeswap route must be the to token\"\n    );\n    \n    pancakeswapRoutes[from][to] = _pancakeswapRoute;\n  }\n\n  // Transfers the funds from the msg.sender to the pool\n  // under normal circumstances, msg.sender is the strategy\n  function poolNotifyFixedTarget(address _token, uint256 _amount) external {\n    uint256 remainingAmount = _amount;\n    // Note: targetToken could only be FARM or NULL. \n    // it is only used to check that the rewardPool is set.\n    if (targetToken == address(0)) {\n      return; // a No-op if target pool is not set yet\n    }\n\n    if (_token == wbnb) {\n      // this is already the right token\n      // Note: Under current structure, this would be FARM.\n      // This would pass on the grain buy back as it would be the special case\n      // designed for NotifyHelper calls\n      // This is assuming that NO strategy would notify profits in FARM\n\n      // IBEP20(_token).safeTransferFrom(msg.sender, profitSharingPool, _amount);\n      // IRewardPool(profitSharingPool).notifyRewardAmount(_amount);\n\n      // send the _amount of wbnb to the cross-chain converter\n    } else {\n\n      // we need to convert _token to FARM\n      if (pancakeswapRoutes[_token][farm].length > 1) {\n        IBEP20(_token).safeTransferFrom(msg.sender, address(this), remainingAmount);\n        uint256 balanceToSwap = IBEP20(_token).balanceOf(address(this));\n        liquidate(_token, wbnb, balanceToSwap);\n\n        // now we can send this token forward\n        uint256 convertedRewardAmount = IBEP20(wbnb).balanceOf(address(this));\n        \n        // IBEP20(farm).safeTransfer(profitSharingPool, convertedRewardAmount);\n        // IRewardPool(profitSharingPool).notifyRewardAmount(convertedRewardAmount);\n\n        // send the token to the cross-chain converter address\n      } else { \n        // else the route does not exist for this token\n        // do not take any fees and revert. \n        // It's better to set the liquidation path then perform it again, \n        // rather then leaving the funds in controller\n        revert(\"FeeRewardForwarder: liquidation path doesn't exist\"); \n      }\n    }\n  }\n\n  function liquidate(address _from, address _to, uint256 balanceToSwap) internal {\n    if(balanceToSwap > 0){\n      IBEP20(_from).safeApprove(pancakeswapRouterV2, 0);\n      IBEP20(_from).safeApprove(pancakeswapRouterV2, balanceToSwap);\n\n      IUniswapV2Router02(pancakeswapRouterV2).swapExactTokensForTokens(\n        balanceToSwap,\n        0,\n        pancakeswapRoutes[_from][_to],\n        address(this),\n        block.timestamp\n      );\n    }\n  }\n}\n"
    },
    "contracts/lib/@harvest-finance/hardworkInterface/IRewardPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\n// Unifying the interface with the Synthetix Reward Pool \ninterface IRewardPool {\n  function rewardToken() external view returns (address);\n  function lpToken() external view returns (address);\n  function duration() external view returns (uint256);\n\n  function periodFinish() external view returns (uint256);\n  function rewardRate() external view returns (uint256);\n  function rewardPerTokenStored() external view returns (uint256);\n\n  function stake(uint256 amountWei) external;\n\n  // `balanceOf` would give the amount staked. \n  // As this is 1 to 1, this is also the holder's share\n  function balanceOf(address holder) external view returns (uint256);\n  // total shares & total lpTokens staked\n  function totalSupply() external view returns(uint256);\n\n  function withdraw(uint256 amountWei) external;\n  function exit() external;\n\n  // get claimed rewards\n  function earned(address holder) external view returns (uint256);\n\n  // claim rewards\n  function getReward() external;\n\n  // notify\n  function notifyRewardAmount(uint256 _amount) external;\n}\n"
    },
    "contracts/lib/@pancakeswap/PancakeRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n *Submitted for verification at BscScan.com on 2020-09-19\n*/\n\npragma solidity 0.6.12;\n\nimport {IBEP20} from \"@pancakeswap/pancake-swap-lib/contracts/token/BEP20/IBEP20.sol\";\nimport {SafeMath} from \"@pancakeswap/pancake-swap-lib/contracts/math/SafeMath.sol\";\nimport {IPancakeERC20} from \"./interfaces/IPancakeERC20.sol\";\nimport {IPancakeFactory} from \"./interfaces/IPancakeFactory.sol\";\nimport {IPancakePair} from \"./interfaces/IPancakePair.sol\";\nimport {IPancakeRouter02} from \"./interfaces/IPancakeRouter02.sol\";\nimport {IWETH} from \"./interfaces/IWETH.sol\";\nimport {PancakeLibrary} from \"./libraries/PancakeLibrary.sol\";\nimport {TransferHelper} from \"./libraries/TransferHelper.sol\";\n\ncontract PancakeRouter is IPancakeRouter02 {\n    using SafeMath for uint;\n\n    address public immutable override factory;\n    address public immutable override WETH;\n\n    modifier ensure(uint deadline) {\n        require(deadline >= block.timestamp, 'PancakeRouter: EXPIRED');\n        _;\n    }\n\n    constructor(address _factory, address _WETH) public {\n        factory = _factory;\n        WETH = _WETH;\n    }\n\n    receive() external payable {\n        assert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract\n    }\n\n    // **** ADD LIQUIDITY ****\n    function _addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin\n    ) internal virtual returns (uint amountA, uint amountB) {\n        // create the pair if it doesn't exist yet\n        if (IPancakeFactory(factory).getPair(tokenA, tokenB) == address(0)) {\n            IPancakeFactory(factory).createPair(tokenA, tokenB);\n        }\n        (uint reserveA, uint reserveB) = PancakeLibrary.getReserves(factory, tokenA, tokenB);\n        if (reserveA == 0 && reserveB == 0) {\n            (amountA, amountB) = (amountADesired, amountBDesired);\n        } else {\n            uint amountBOptimal = PancakeLibrary.quote(amountADesired, reserveA, reserveB);\n            if (amountBOptimal <= amountBDesired) {\n                require(amountBOptimal >= amountBMin, 'PancakeRouter: INSUFFICIENT_B_AMOUNT');\n                (amountA, amountB) = (amountADesired, amountBOptimal);\n            } else {\n                uint amountAOptimal = PancakeLibrary.quote(amountBDesired, reserveB, reserveA);\n                assert(amountAOptimal <= amountADesired);\n                require(amountAOptimal >= amountAMin, 'PancakeRouter: INSUFFICIENT_A_AMOUNT');\n                (amountA, amountB) = (amountAOptimal, amountBDesired);\n            }\n        }\n    }\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external virtual override ensure(deadline) returns (uint amountA, uint amountB, uint liquidity) {\n        (amountA, amountB) = _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);\n        address pair = PancakeLibrary.pairFor(factory, tokenA, tokenB);\n        TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);\n        TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);\n        liquidity = IPancakePair(pair).mint(to);\n    }\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external virtual override payable ensure(deadline) returns (uint amountToken, uint amountETH, uint liquidity) {\n        (amountToken, amountETH) = _addLiquidity(\n            token,\n            WETH,\n            amountTokenDesired,\n            msg.value,\n            amountTokenMin,\n            amountETHMin\n        );\n        address pair = PancakeLibrary.pairFor(factory, token, WETH);\n        TransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken);\n        IWETH(WETH).deposit{value: amountETH}();\n        assert(IWETH(WETH).transfer(pair, amountETH));\n        liquidity = IPancakePair(pair).mint(to);\n        // refund dust eth, if any\n        if (msg.value > amountETH) TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);\n    }\n\n    // **** REMOVE LIQUIDITY ****\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) public virtual override ensure(deadline) returns (uint amountA, uint amountB) {\n        address pair = PancakeLibrary.pairFor(factory, tokenA, tokenB);\n        IPancakeERC20(pair).transferFrom(msg.sender, pair, liquidity); // send liquidity to pair\n        (uint amount0, uint amount1) = IPancakePair(pair).burn(to);\n        (address token0,) = PancakeLibrary.sortTokens(tokenA, tokenB);\n        (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);\n        require(amountA >= amountAMin, 'PancakeRouter: INSUFFICIENT_A_AMOUNT');\n        require(amountB >= amountBMin, 'PancakeRouter: INSUFFICIENT_B_AMOUNT');\n    }\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) public virtual override ensure(deadline) returns (uint amountToken, uint amountETH) {\n        (amountToken, amountETH) = removeLiquidity(\n            token,\n            WETH,\n            liquidity,\n            amountTokenMin,\n            amountETHMin,\n            address(this),\n            deadline\n        );\n        TransferHelper.safeTransfer(token, to, amountToken);\n        IWETH(WETH).withdraw(amountETH);\n        TransferHelper.safeTransferETH(to, amountETH);\n    }\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external virtual override returns (uint amountA, uint amountB) {\n        address pair = PancakeLibrary.pairFor(factory, tokenA, tokenB);\n        uint value = approveMax ? uint(-1) : liquidity;\n        IPancakeERC20(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n        (amountA, amountB) = removeLiquidity(tokenA, tokenB, liquidity, amountAMin, amountBMin, to, deadline);\n    }\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external virtual override returns (uint amountToken, uint amountETH) {\n        address pair = PancakeLibrary.pairFor(factory, token, WETH);\n        uint value = approveMax ? uint(-1) : liquidity;\n        IPancakeERC20(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n        (amountToken, amountETH) = removeLiquidityETH(token, liquidity, amountTokenMin, amountETHMin, to, deadline);\n    }\n\n    // **** REMOVE LIQUIDITY (supporting fee-on-transfer tokens) ****\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) public virtual override ensure(deadline) returns (uint amountETH) {\n        (, amountETH) = removeLiquidity(\n            token,\n            WETH,\n            liquidity,\n            amountTokenMin,\n            amountETHMin,\n            address(this),\n            deadline\n        );\n        TransferHelper.safeTransfer(token, to, IBEP20(token).balanceOf(address(this)));\n        IWETH(WETH).withdraw(amountETH);\n        TransferHelper.safeTransferETH(to, amountETH);\n    }\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external virtual override returns (uint amountETH) {\n        address pair = PancakeLibrary.pairFor(factory, token, WETH);\n        uint value = approveMax ? uint(-1) : liquidity;\n        IPancakeERC20(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n        amountETH = removeLiquidityETHSupportingFeeOnTransferTokens(\n            token, liquidity, amountTokenMin, amountETHMin, to, deadline\n        );\n    }\n\n    // **** SWAP ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swap(uint[] memory amounts, address[] memory path, address _to) internal virtual {\n        for (uint i; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0,) = PancakeLibrary.sortTokens(input, output);\n            uint amountOut = amounts[i + 1];\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n            address to = i < path.length - 2 ? PancakeLibrary.pairFor(factory, output, path[i + 2]) : _to;\n            IPancakePair(PancakeLibrary.pairFor(factory, input, output)).swap(\n                amount0Out, amount1Out, to, new bytes(0)\n            );\n        }\n    }\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external virtual override ensure(deadline) returns (uint[] memory amounts) {\n        amounts = PancakeLibrary.getAmountsOut(factory, amountIn, path);\n        require(amounts[amounts.length - 1] >= amountOutMin, 'PancakeRouter: INSUFFICIENT_OUTPUT_AMOUNT');\n        TransferHelper.safeTransferFrom(\n            path[0], msg.sender, PancakeLibrary.pairFor(factory, path[0], path[1]), amounts[0]\n        );\n        _swap(amounts, path, to);\n    }\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external virtual override ensure(deadline) returns (uint[] memory amounts) {\n        amounts = PancakeLibrary.getAmountsIn(factory, amountOut, path);\n        require(amounts[0] <= amountInMax, 'PancakeRouter: EXCESSIVE_INPUT_AMOUNT');\n        TransferHelper.safeTransferFrom(\n            path[0], msg.sender, PancakeLibrary.pairFor(factory, path[0], path[1]), amounts[0]\n        );\n        _swap(amounts, path, to);\n    }\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        virtual\n        override\n        payable\n        ensure(deadline)\n        returns (uint[] memory amounts)\n    {\n        require(path[0] == WETH, 'PancakeRouter: INVALID_PATH');\n        amounts = PancakeLibrary.getAmountsOut(factory, msg.value, path);\n        require(amounts[amounts.length - 1] >= amountOutMin, 'PancakeRouter: INSUFFICIENT_OUTPUT_AMOUNT');\n        IWETH(WETH).deposit{value: amounts[0]}();\n        assert(IWETH(WETH).transfer(PancakeLibrary.pairFor(factory, path[0], path[1]), amounts[0]));\n        _swap(amounts, path, to);\n    }\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        virtual\n        override\n        ensure(deadline)\n        returns (uint[] memory amounts)\n    {\n        require(path[path.length - 1] == WETH, 'PancakeRouter: INVALID_PATH');\n        amounts = PancakeLibrary.getAmountsIn(factory, amountOut, path);\n        require(amounts[0] <= amountInMax, 'PancakeRouter: EXCESSIVE_INPUT_AMOUNT');\n        TransferHelper.safeTransferFrom(\n            path[0], msg.sender, PancakeLibrary.pairFor(factory, path[0], path[1]), amounts[0]\n        );\n        _swap(amounts, path, address(this));\n        IWETH(WETH).withdraw(amounts[amounts.length - 1]);\n        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\n    }\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        virtual\n        override\n        ensure(deadline)\n        returns (uint[] memory amounts)\n    {\n        require(path[path.length - 1] == WETH, 'PancakeRouter: INVALID_PATH');\n        amounts = PancakeLibrary.getAmountsOut(factory, amountIn, path);\n        require(amounts[amounts.length - 1] >= amountOutMin, 'PancakeRouter: INSUFFICIENT_OUTPUT_AMOUNT');\n        TransferHelper.safeTransferFrom(\n            path[0], msg.sender, PancakeLibrary.pairFor(factory, path[0], path[1]), amounts[0]\n        );\n        _swap(amounts, path, address(this));\n        IWETH(WETH).withdraw(amounts[amounts.length - 1]);\n        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\n    }\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        virtual\n        override\n        payable\n        ensure(deadline)\n        returns (uint[] memory amounts)\n    {\n        require(path[0] == WETH, 'PancakeRouter: INVALID_PATH');\n        amounts = PancakeLibrary.getAmountsIn(factory, amountOut, path);\n        require(amounts[0] <= msg.value, 'PancakeRouter: EXCESSIVE_INPUT_AMOUNT');\n        IWETH(WETH).deposit{value: amounts[0]}();\n        assert(IWETH(WETH).transfer(PancakeLibrary.pairFor(factory, path[0], path[1]), amounts[0]));\n        _swap(amounts, path, to);\n        // refund dust eth, if any\n        if (msg.value > amounts[0]) TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]);\n    }\n\n    // **** SWAP (supporting fee-on-transfer tokens) ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to) internal virtual {\n        for (uint i; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0,) = PancakeLibrary.sortTokens(input, output);\n            IPancakePair pair = IPancakePair(PancakeLibrary.pairFor(factory, input, output));\n            uint amountInput;\n            uint amountOutput;\n            { // scope to avoid stack too deep errors\n            (uint reserve0, uint reserve1,) = pair.getReserves();\n            (uint reserveInput, uint reserveOutput) = input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n            amountInput = IBEP20(input).balanceOf(address(pair)).sub(reserveInput);\n            amountOutput = PancakeLibrary.getAmountOut(amountInput, reserveInput, reserveOutput);\n            }\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\n            address to = i < path.length - 2 ? PancakeLibrary.pairFor(factory, output, path[i + 2]) : _to;\n            pair.swap(amount0Out, amount1Out, to, new bytes(0));\n        }\n    }\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external virtual override ensure(deadline) {\n        TransferHelper.safeTransferFrom(\n            path[0], msg.sender, PancakeLibrary.pairFor(factory, path[0], path[1]), amountIn\n        );\n        uint balanceBefore = IBEP20(path[path.length - 1]).balanceOf(to);\n        _swapSupportingFeeOnTransferTokens(path, to);\n        require(\n            IBEP20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= amountOutMin,\n            'PancakeRouter: INSUFFICIENT_OUTPUT_AMOUNT'\n        );\n    }\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    )\n        external\n        virtual\n        override\n        payable\n        ensure(deadline)\n    {\n        require(path[0] == WETH, 'PancakeRouter: INVALID_PATH');\n        uint amountIn = msg.value;\n        IWETH(WETH).deposit{value: amountIn}();\n        assert(IWETH(WETH).transfer(PancakeLibrary.pairFor(factory, path[0], path[1]), amountIn));\n        uint balanceBefore = IBEP20(path[path.length - 1]).balanceOf(to);\n        _swapSupportingFeeOnTransferTokens(path, to);\n        require(\n            IBEP20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= amountOutMin,\n            'PancakeRouter: INSUFFICIENT_OUTPUT_AMOUNT'\n        );\n    }\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    )\n        external\n        virtual\n        override\n        ensure(deadline)\n    {\n        require(path[path.length - 1] == WETH, 'PancakeRouter: INVALID_PATH');\n        TransferHelper.safeTransferFrom(\n            path[0], msg.sender, PancakeLibrary.pairFor(factory, path[0], path[1]), amountIn\n        );\n        _swapSupportingFeeOnTransferTokens(path, address(this));\n        uint amountOut = IBEP20(WETH).balanceOf(address(this));\n        require(amountOut >= amountOutMin, 'PancakeRouter: INSUFFICIENT_OUTPUT_AMOUNT');\n        IWETH(WETH).withdraw(amountOut);\n        TransferHelper.safeTransferETH(to, amountOut);\n    }\n\n    // **** LIBRARY FUNCTIONS ****\n    function quote(uint amountA, uint reserveA, uint reserveB) public pure virtual override returns (uint amountB) {\n        return PancakeLibrary.quote(amountA, reserveA, reserveB);\n    }\n\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut)\n        public\n        pure\n        virtual\n        override\n        returns (uint amountOut)\n    {\n        return PancakeLibrary.getAmountOut(amountIn, reserveIn, reserveOut);\n    }\n\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut)\n        public\n        pure\n        virtual\n        override\n        returns (uint amountIn)\n    {\n        return PancakeLibrary.getAmountIn(amountOut, reserveIn, reserveOut);\n    }\n\n    function getAmountsOut(uint amountIn, address[] memory path)\n        public\n        view\n        virtual\n        override\n        returns (uint[] memory amounts)\n    {\n        return PancakeLibrary.getAmountsOut(factory, amountIn, path);\n    }\n\n    function getAmountsIn(uint amountOut, address[] memory path)\n        public\n        view\n        virtual\n        override\n        returns (uint[] memory amounts)\n    {\n        return PancakeLibrary.getAmountsIn(factory, amountOut, path);\n    }\n}"
    },
    "contracts/lib/@pancakeswap/interfaces/IPancakeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ninterface IPancakeERC20 {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n}"
    },
    "contracts/lib/@pancakeswap/interfaces/IPancakeFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ninterface IPancakeFactory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}\n"
    },
    "contracts/lib/@pancakeswap/interfaces/IPancakePair.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ninterface IPancakePair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}"
    },
    "contracts/lib/@pancakeswap/interfaces/IPancakeRouter02.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport {IPancakeRouter01} from \"./IPancakeRouter01.sol\";\n\ninterface IPancakeRouter02 is IPancakeRouter01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n\ninterface IPancakePair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}"
    },
    "contracts/lib/@pancakeswap/interfaces/IWETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ninterface IWETH {\n    function deposit() external payable;\n    function transfer(address to, uint value) external returns (bool);\n    function withdraw(uint) external;\n}"
    },
    "contracts/lib/@pancakeswap/libraries/PancakeLibrary.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport {SafeMath} from \"@pancakeswap/pancake-swap-lib/contracts/math/SafeMath.sol\";\nimport {IPancakePair} from \"../interfaces/IPancakePair.sol\";\n\nlibrary PancakeLibrary {\n    using SafeMath for uint;\n\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n        require(tokenA != tokenB, 'PancakeLibrary: IDENTICAL_ADDRESSES');\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        require(token0 != address(0), 'PancakeLibrary: ZERO_ADDRESS');\n    }\n\n    // calculates the CREATE2 address for a pair without making any external calls\n    function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        pair = address(uint(keccak256(abi.encodePacked(\n                hex'ff',\n                factory,\n                keccak256(abi.encodePacked(token0, token1)),\n                hex'd0d4c4cd0848c93cb4fd1f498d7013ee6bfb25783ea21593d5834f5d250ece66' // init code hash\n            ))));\n    }\n\n    // fetches and sorts the reserves for a pair\n    function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {\n        (address token0,) = sortTokens(tokenA, tokenB);\n        pairFor(factory, tokenA, tokenB);\n        (uint reserve0, uint reserve1,) = IPancakePair(pairFor(factory, tokenA, tokenB)).getReserves();\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    }\n\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n    function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {\n        require(amountA > 0, 'PancakeLibrary: INSUFFICIENT_AMOUNT');\n        require(reserveA > 0 && reserveB > 0, 'PancakeLibrary: INSUFFICIENT_LIQUIDITY');\n        amountB = amountA.mul(reserveB) / reserveA;\n    }\n\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\n        require(amountIn > 0, 'PancakeLibrary: INSUFFICIENT_INPUT_AMOUNT');\n        require(reserveIn > 0 && reserveOut > 0, 'PancakeLibrary: INSUFFICIENT_LIQUIDITY');\n        uint amountInWithFee = amountIn.mul(998);\n        uint numerator = amountInWithFee.mul(reserveOut);\n        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    }\n\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {\n        require(amountOut > 0, 'PancakeLibrary: INSUFFICIENT_OUTPUT_AMOUNT');\n        require(reserveIn > 0 && reserveOut > 0, 'PancakeLibrary: INSUFFICIENT_LIQUIDITY');\n        uint numerator = reserveIn.mul(amountOut).mul(1000);\n        uint denominator = reserveOut.sub(amountOut).mul(998);\n        amountIn = (numerator / denominator).add(1);\n    }\n\n    // performs chained getAmountOut calculations on any number of pairs\n    function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) {\n        require(path.length >= 2, 'PancakeLibrary: INVALID_PATH');\n        amounts = new uint[](path.length);\n        amounts[0] = amountIn;\n        for (uint i; i < path.length - 1; i++) {\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\n        }\n    }\n\n    // performs chained getAmountIn calculations on any number of pairs\n    function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) {\n        require(path.length >= 2, 'PancakeLibrary: INVALID_PATH');\n        amounts = new uint[](path.length);\n        amounts[amounts.length - 1] = amountOut;\n        for (uint i = path.length - 1; i > 0; i--) {\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\n        }\n    }\n}"
    },
    "contracts/lib/@pancakeswap/libraries/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    function safeApprove(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n    }\n\n    function safeTransfer(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n    }\n\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n    }\n\n    function safeTransferETH(address to, uint value) internal {\n        (bool success,) = to.call{value:value}(new bytes(0));\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\n    }\n}"
    },
    "contracts/lib/@pancakeswap/interfaces/IPancakeRouter01.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ninterface IPancakeRouter01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}"
    },
    "contracts/lib/@pancakeswap/PancakePair.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport {PancakeERC20} from \"./PancakeERC20.sol\";\nimport {IPancakeCallee} from \"./interfaces/IPancakeCallee.sol\";\nimport {IPancakePair} from \"./interfaces/IPancakePair.sol\";\nimport {IPancakeFactory} from \"./interfaces/IPancakeFactory.sol\";\nimport {UQ112x112} from \"./libraries/UQ112x112.sol\";\nimport {SafeMath} from \"@pancakeswap/pancake-swap-lib/contracts/math/SafeMath.sol\";\nimport {IBEP20} from \"@pancakeswap/pancake-swap-lib/contracts/token/BEP20/IBEP20.sol\";\n\ncontract PancakePair is IPancakePair, PancakeERC20 {\n    using SafeMath  for uint;\n    using UQ112x112 for uint224;\n\n    uint public constant override MINIMUM_LIQUIDITY = 10**3;\n    bytes4 private constant SELECTOR = bytes4(keccak256(bytes('transfer(address,uint256)')));\n\n    address public override factory;\n    address public override token0;\n    address public override token1;\n\n    uint112 private reserve0;           // uses single storage slot, accessible via getReserves\n    uint112 private reserve1;           // uses single storage slot, accessible via getReserves\n    uint32  private blockTimestampLast; // uses single storage slot, accessible via getReserves\n\n    uint public override price0CumulativeLast;\n    uint public override price1CumulativeLast;\n    uint public override kLast; // reserve0 * reserve1, as of immediately after the most recent liquidity event\n\n    uint private unlocked = 1;\n    modifier lock() {\n        require(unlocked == 1, 'Pancake: LOCKED');\n        unlocked = 0;\n        _;\n        unlocked = 1;\n    }\n\n    function getReserves() public view override returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) {\n        _reserve0 = reserve0;\n        _reserve1 = reserve1;\n        _blockTimestampLast = blockTimestampLast;\n    }\n\n    function _safeTransfer(address token, address to, uint value) private {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'Pancake: TRANSFER_FAILED');\n    }\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    constructor() public {\n        factory = msg.sender;\n    }\n\n    // called once by the factory at time of deployment\n    function initialize(address _token0, address _token1) external override {\n        require(msg.sender == factory, 'Pancake: FORBIDDEN'); // sufficient check\n        token0 = _token0;\n        token1 = _token1;\n    }\n\n    // update reserves and, on the first call per block, price accumulators\n    function _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private {\n        require(balance0 <= uint112(-1) && balance1 <= uint112(-1), 'Pancake: OVERFLOW');\n        uint32 blockTimestamp = uint32(block.timestamp % 2**32);\n        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\n        if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {\n            // * never overflows, and + overflow is desired\n            price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;\n            price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;\n        }\n        reserve0 = uint112(balance0);\n        reserve1 = uint112(balance1);\n        blockTimestampLast = blockTimestamp;\n        emit Sync(reserve0, reserve1);\n    }\n\n    // if fee is on, mint liquidity equivalent to 1/6th of the growth in sqrt(k)\n    function _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) {\n        address feeTo = IPancakeFactory(factory).feeTo();\n        feeOn = feeTo != address(0);\n        uint _kLast = kLast; // gas savings\n        if (feeOn) {\n            if (_kLast != 0) {\n                uint rootK = SafeMath.sqrt(uint(_reserve0).mul(_reserve1));\n                uint rootKLast = SafeMath.sqrt(_kLast);\n                if (rootK > rootKLast) {\n                    uint numerator = totalSupply.mul(rootK.sub(rootKLast));\n                    uint denominator = rootK.mul(3).add(rootKLast);\n                    uint liquidity = numerator / denominator;\n                    if (liquidity > 0) _mint(feeTo, liquidity);\n                }\n            }\n        } else if (_kLast != 0) {\n            kLast = 0;\n        }\n    }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function mint(address to) external override lock returns (uint liquidity) {\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings\n        uint balance0 = IBEP20(token0).balanceOf(address(this));\n        uint balance1 = IBEP20(token1).balanceOf(address(this));\n        uint amount0 = balance0.sub(_reserve0);\n        uint amount1 = balance1.sub(_reserve1);\n\n        bool feeOn = _mintFee(_reserve0, _reserve1);\n        uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\n        if (_totalSupply == 0) {\n            liquidity = SafeMath.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);\n           _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens\n        } else {\n            liquidity = SafeMath.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);\n        }\n        require(liquidity > 0, 'Pancake: INSUFFICIENT_LIQUIDITY_MINTED');\n        _mint(to, liquidity);\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n        if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date\n        emit Mint(msg.sender, amount0, amount1);\n    }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function burn(address to) external override lock returns (uint amount0, uint amount1) {\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings\n        address _token0 = token0;                                // gas savings\n        address _token1 = token1;                                // gas savings\n        uint balance0 = IBEP20(_token0).balanceOf(address(this));\n        uint balance1 = IBEP20(_token1).balanceOf(address(this));\n        uint liquidity = balanceOf[address(this)];\n\n        bool feeOn = _mintFee(_reserve0, _reserve1);\n        uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\n        amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution\n        amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution\n        require(amount0 > 0 && amount1 > 0, 'Pancake: INSUFFICIENT_LIQUIDITY_BURNED');\n        _burn(address(this), liquidity);\n        _safeTransfer(_token0, to, amount0);\n        _safeTransfer(_token1, to, amount1);\n        balance0 = IBEP20(_token0).balanceOf(address(this));\n        balance1 = IBEP20(_token1).balanceOf(address(this));\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n        if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date\n        emit Burn(msg.sender, amount0, amount1, to);\n    }\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external override lock {\n        require(amount0Out > 0 || amount1Out > 0, 'Pancake: INSUFFICIENT_OUTPUT_AMOUNT');\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings\n        require(amount0Out < _reserve0 && amount1Out < _reserve1, 'Pancake: INSUFFICIENT_LIQUIDITY');\n\n        uint balance0;\n        uint balance1;\n        { // scope for _token{0,1}, avoids stack too deep errors\n        address _token0 = token0;\n        address _token1 = token1;\n        require(to != _token0 && to != _token1, 'Pancake: INVALID_TO');\n        if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens\n        if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens\n        if (data.length > 0) IPancakeCallee(to).pancakeCall(msg.sender, amount0Out, amount1Out, data);\n        balance0 = IBEP20(_token0).balanceOf(address(this));\n        balance1 = IBEP20(_token1).balanceOf(address(this));\n        }\n        uint amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;\n        uint amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;\n        require(amount0In > 0 || amount1In > 0, 'Pancake: INSUFFICIENT_INPUT_AMOUNT');\n        { // scope for reserve{0,1}Adjusted, avoids stack too deep errors\n        uint balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(2));\n        uint balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(2));\n        require(balance0Adjusted.mul(balance1Adjusted) >= uint(_reserve0).mul(_reserve1).mul(1000**2), 'Pancake: K');\n        }\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);\n    }\n\n    // force balances to match reserves\n    function skim(address to) external override lock {\n        address _token0 = token0; // gas savings\n        address _token1 = token1; // gas savings\n        _safeTransfer(_token0, to, IBEP20(_token0).balanceOf(address(this)).sub(reserve0));\n        _safeTransfer(_token1, to, IBEP20(_token1).balanceOf(address(this)).sub(reserve1));\n    }\n\n    // force reserves to match balances\n    function sync() external override lock {\n        _update(IBEP20(token0).balanceOf(address(this)), IBEP20(token1).balanceOf(address(this)), reserve0, reserve1);\n    }\n}"
    },
    "contracts/lib/@pancakeswap/PancakeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport {SafeMath} from \"@pancakeswap/pancake-swap-lib/contracts/math/SafeMath.sol\";\nimport {IPancakeERC20} from \"./interfaces/IPancakeERC20.sol\";\n \ncontract PancakeERC20 is IPancakeERC20 {\n    using SafeMath for uint;\n\n    string public constant override name = 'Pancake LPs';\n    string public constant override symbol = 'Cake-LP';\n    uint8 public constant override decimals = 18;\n    uint  public override totalSupply;\n    mapping(address => uint) public override balanceOf;\n    mapping(address => mapping(address => uint)) public override allowance;\n\n    bytes32 public override DOMAIN_SEPARATOR;\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant override PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n    mapping(address => uint) public override nonces;\n\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    constructor() public {\n        uint chainId;\n        assembly {\n            chainId := chainid()\n        }\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\n                keccak256(bytes(name)),\n                keccak256(bytes('1')),\n                chainId,\n                address(this)\n            )\n        );\n    }\n\n    function _mint(address to, uint value) internal {\n        totalSupply = totalSupply.add(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(address(0), to, value);\n    }\n\n    function _burn(address from, uint value) internal {\n        balanceOf[from] = balanceOf[from].sub(value);\n        totalSupply = totalSupply.sub(value);\n        emit Transfer(from, address(0), value);\n    }\n\n    function _approve(address owner, address spender, uint value) private {\n        allowance[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    function _transfer(address from, address to, uint value) private {\n        balanceOf[from] = balanceOf[from].sub(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(from, to, value);\n    }\n\n    function approve(address spender, uint value) external override returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    function transfer(address to, uint value) external override returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint value) external override returns (bool) {\n        if (allowance[from][msg.sender] != uint(-1)) {\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\n        }\n        _transfer(from, to, value);\n        return true;\n    }\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external override {\n        require(deadline >= block.timestamp, 'Pancake: EXPIRED');\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                '\\x19\\x01',\n                DOMAIN_SEPARATOR,\n                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\n            )\n        );\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(recoveredAddress != address(0) && recoveredAddress == owner, 'Pancake: INVALID_SIGNATURE');\n        _approve(owner, spender, value);\n    }\n}"
    },
    "contracts/lib/@pancakeswap/interfaces/IPancakeCallee.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ninterface IPancakeCallee {\n    function pancakeCall(address sender, uint amount0, uint amount1, bytes calldata data) external;\n}"
    },
    "contracts/lib/@pancakeswap/libraries/UQ112x112.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\n// range: [0, 2**112 - 1]\n// resolution: 1 / 2**112\nlibrary UQ112x112 {\n    uint224 constant Q112 = 2**112;\n\n    // encode a uint112 as a UQ112x112\n    function encode(uint112 y) internal pure returns (uint224 z) {\n        z = uint224(y) * Q112; // never overflows\n    }\n\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\n    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {\n        z = x / uint224(y);\n    }\n}"
    },
    "contracts/lib/@pancakeswap/PancakeChef.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport {Ownable} from \"@pancakeswap/pancake-swap-lib/contracts/access/Ownable.sol\";\nimport {SafeMath} from \"@pancakeswap/pancake-swap-lib/contracts/math/SafeMath.sol\";\nimport {IBEP20} from \"@pancakeswap/pancake-swap-lib/contracts/token/BEP20/IBEP20.sol\";\nimport {SafeBEP20} from \"@pancakeswap/pancake-swap-lib/contracts/token/BEP20/SafeBEP20.sol\";\nimport {IMigratorChef} from \"./interfaces/IMigratorChef.sol\";\nimport {CakeToken} from \"./CakeToken.sol\";\nimport {SyrupBar} from \"./SyrupBar.sol\";\n\n// MasterChef is the master of Cake. He can make Cake and he is a fair guy.\n//\n// Note that it's ownable and the owner wields tremendous power. The ownership\n// will be transferred to a governance smart contract once CAKE is sufficiently\n// distributed and the community can show to govern itself.\n//\n// Have fun reading it. Hopefully it's bug-free. God bless.\ncontract PancakeChef is Ownable {\n    using SafeMath for uint256;\n    using SafeBEP20 for IBEP20;\n\n    // Info of each user.\n    struct UserInfo {\n        uint256 amount;     // How many LP tokens the user has provided.\n        uint256 rewardDebt; // Reward debt. See explanation below.\n        //\n        // We do some fancy math here. Basically, any point in time, the amount of CAKEs\n        // entitled to a user but is pending to be distributed is:\n        //\n        //   pending reward = (user.amount * pool.accCakePerShare) - user.rewardDebt\n        //\n        // Whenever a user deposits or withdraws LP tokens to a pool. Here's what happens:\n        //   1. The pool's `accCakePerShare` (and `lastRewardBlock`) gets updated.\n        //   2. User receives the pending reward sent to his/her address.\n        //   3. User's `amount` gets updated.\n        //   4. User's `rewardDebt` gets updated.\n    }\n\n    // Info of each pool.\n    struct PoolInfo {\n        IBEP20 lpToken;           // Address of LP token contract.\n        uint256 allocPoint;       // How many allocation points assigned to this pool. CAKEs to distribute per block.\n        uint256 lastRewardBlock;  // Last block number that CAKEs distribution occurs.\n        uint256 accCakePerShare; // Accumulated CAKEs per share, times 1e12. See below.\n    }\n\n    // The CAKE TOKEN!\n    CakeToken public cake;\n    // The SYRUP TOKEN!\n    SyrupBar public syrup;\n    // Dev address.\n    address public devaddr;\n    // CAKE tokens created per block.\n    uint256 public cakePerBlock;\n    // Bonus muliplier for early cake makers.\n    uint256 public BONUS_MULTIPLIER = 1;\n    // The migrator contract. It has a lot of power. Can only be set through governance (owner).\n    IMigratorChef public migrator;\n\n    // Info of each pool.\n    PoolInfo[] public poolInfo;\n    // Info of each user that stakes LP tokens.\n    mapping (uint256 => mapping (address => UserInfo)) public userInfo;\n    // Total allocation poitns. Must be the sum of all allocation points in all pools.\n    uint256 public totalAllocPoint = 0;\n    // The block number when CAKE mining starts.\n    uint256 public startBlock;\n\n    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\n    event EmergencyWithdraw(address indexed user, uint256 indexed pid, uint256 amount);\n\n    constructor(\n        CakeToken _cake,\n        SyrupBar _syrup,\n        address _devaddr,\n        uint256 _cakePerBlock,\n        uint256 _startBlock\n    ) public {\n        cake = _cake;\n        syrup = _syrup;\n        devaddr = _devaddr;\n        cakePerBlock = _cakePerBlock;\n        startBlock = _startBlock;\n\n        // staking pool\n        poolInfo.push(PoolInfo({\n            lpToken: _cake,\n            allocPoint: 1000,\n            lastRewardBlock: startBlock,\n            accCakePerShare: 0\n        }));\n\n        totalAllocPoint = 1000;\n\n    }\n\n    function updateMultiplier(uint256 multiplierNumber) public onlyOwner {\n        BONUS_MULTIPLIER = multiplierNumber;\n    }\n\n    function poolLength() external view returns (uint256) {\n        return poolInfo.length;\n    }\n\n    // Add a new lp to the pool. Can only be called by the owner.\n    // XXX DO NOT add the same LP token more than once. Rewards will be messed up if you do.\n    function add(uint256 _allocPoint, IBEP20 _lpToken, bool _withUpdate) public onlyOwner {\n        if (_withUpdate) {\n            massUpdatePools();\n        }\n        uint256 lastRewardBlock = block.number > startBlock ? block.number : startBlock;\n        totalAllocPoint = totalAllocPoint.add(_allocPoint);\n        poolInfo.push(PoolInfo({\n            lpToken: _lpToken,\n            allocPoint: _allocPoint,\n            lastRewardBlock: lastRewardBlock,\n            accCakePerShare: 0\n        }));\n        updateStakingPool();\n    }\n\n    // Update the given pool's CAKE allocation point. Can only be called by the owner.\n    function set(uint256 _pid, uint256 _allocPoint, bool _withUpdate) public onlyOwner {\n        if (_withUpdate) {\n            massUpdatePools();\n        }\n        totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(_allocPoint);\n        uint256 prevAllocPoint = poolInfo[_pid].allocPoint;\n        poolInfo[_pid].allocPoint = _allocPoint;\n        if (prevAllocPoint != _allocPoint) {\n            updateStakingPool();\n        }\n    }\n\n    function updateStakingPool() internal {\n        uint256 length = poolInfo.length;\n        uint256 points = 0;\n        for (uint256 pid = 1; pid < length; ++pid) {\n            points = points.add(poolInfo[pid].allocPoint);\n        }\n        if (points != 0) {\n            points = points.div(3);\n            totalAllocPoint = totalAllocPoint.sub(poolInfo[0].allocPoint).add(points);\n            poolInfo[0].allocPoint = points;\n        }\n    }\n\n    // Set the migrator contract. Can only be called by the owner.\n    function setMigrator(IMigratorChef _migrator) public onlyOwner {\n        migrator = _migrator;\n    }\n\n    // Migrate lp token to another lp contract. Can be called by anyone. We trust that migrator contract is good.\n    function migrate(uint256 _pid) public {\n        require(address(migrator) != address(0), \"migrate: no migrator\");\n        PoolInfo storage pool = poolInfo[_pid];\n        IBEP20 lpToken = pool.lpToken;\n        uint256 bal = lpToken.balanceOf(address(this));\n        lpToken.safeApprove(address(migrator), bal);\n        IBEP20 newLpToken = migrator.migrate(lpToken);\n        require(bal == newLpToken.balanceOf(address(this)), \"migrate: bad\");\n        pool.lpToken = newLpToken;\n    }\n\n    // Return reward multiplier over the given _from to _to block.\n    function getMultiplier(uint256 _from, uint256 _to) public view returns (uint256) {\n        return _to.sub(_from).mul(BONUS_MULTIPLIER);\n    }\n\n    // View function to see pending CAKEs on frontend.\n    function pendingCake(uint256 _pid, address _user) external view returns (uint256) {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][_user];\n        uint256 accCakePerShare = pool.accCakePerShare;\n        uint256 lpSupply = pool.lpToken.balanceOf(address(this));\n        if (block.number > pool.lastRewardBlock && lpSupply != 0) {\n            uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);\n            uint256 cakeReward = multiplier.mul(cakePerBlock).mul(pool.allocPoint).div(totalAllocPoint);\n            accCakePerShare = accCakePerShare.add(cakeReward.mul(1e12).div(lpSupply));\n        }\n        return user.amount.mul(accCakePerShare).div(1e12).sub(user.rewardDebt);\n    }\n\n    // Update reward variables for all pools. Be careful of gas spending!\n    function massUpdatePools() public {\n        uint256 length = poolInfo.length;\n        for (uint256 pid = 0; pid < length; ++pid) {\n            updatePool(pid);\n        }\n    }\n\n\n    // Update reward variables of the given pool to be up-to-date.\n    function updatePool(uint256 _pid) public {\n        PoolInfo storage pool = poolInfo[_pid];\n        if (block.number <= pool.lastRewardBlock) {\n            return;\n        }\n        uint256 lpSupply = pool.lpToken.balanceOf(address(this));\n        if (lpSupply == 0) {\n            pool.lastRewardBlock = block.number;\n            return;\n        }\n        uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);\n        uint256 cakeReward = multiplier.mul(cakePerBlock).mul(pool.allocPoint).div(totalAllocPoint);\n        cake.mint(devaddr, cakeReward.div(10));\n        cake.mint(address(syrup), cakeReward);\n        pool.accCakePerShare = pool.accCakePerShare.add(cakeReward.mul(1e12).div(lpSupply));\n        pool.lastRewardBlock = block.number;\n    }\n\n    // Deposit LP tokens to MasterChef for CAKE allocation.\n    function deposit(uint256 _pid, uint256 _amount) public {\n\n        require (_pid != 0, 'deposit CAKE by staking');\n\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        updatePool(_pid);\n        if (user.amount > 0) {\n            uint256 pending = user.amount.mul(pool.accCakePerShare).div(1e12).sub(user.rewardDebt);\n            if(pending > 0) {\n                safeCakeTransfer(msg.sender, pending);\n            }\n        }\n        if (_amount > 0) {\n            pool.lpToken.safeTransferFrom(address(msg.sender), address(this), _amount);\n            user.amount = user.amount.add(_amount);\n        }\n        user.rewardDebt = user.amount.mul(pool.accCakePerShare).div(1e12);\n        emit Deposit(msg.sender, _pid, _amount);\n    }\n\n    // Withdraw LP tokens from MasterChef.\n    function withdraw(uint256 _pid, uint256 _amount) public {\n\n        require (_pid != 0, 'withdraw CAKE by unstaking');\n\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        require(user.amount >= _amount, \"withdraw: not good\");\n        updatePool(_pid);\n        uint256 pending = user.amount.mul(pool.accCakePerShare).div(1e12).sub(user.rewardDebt);\n        if(pending > 0) {\n            safeCakeTransfer(msg.sender, pending);\n        }\n        if(_amount > 0) {\n            user.amount = user.amount.sub(_amount);\n            pool.lpToken.safeTransfer(address(msg.sender), _amount);\n        }\n        user.rewardDebt = user.amount.mul(pool.accCakePerShare).div(1e12);\n        emit Withdraw(msg.sender, _pid, _amount);\n    }\n\n    // Stake CAKE tokens to MasterChef\n    function enterStaking(uint256 _amount) public {\n        PoolInfo storage pool = poolInfo[0];\n        UserInfo storage user = userInfo[0][msg.sender];\n        updatePool(0);\n        if (user.amount > 0) {\n            uint256 pending = user.amount.mul(pool.accCakePerShare).div(1e12).sub(user.rewardDebt);\n            if(pending > 0) {\n                safeCakeTransfer(msg.sender, pending);\n            }\n        }\n        if(_amount > 0) {\n            pool.lpToken.safeTransferFrom(address(msg.sender), address(this), _amount);\n            user.amount = user.amount.add(_amount);\n        }\n        user.rewardDebt = user.amount.mul(pool.accCakePerShare).div(1e12);\n\n        syrup.mint(msg.sender, _amount);\n        emit Deposit(msg.sender, 0, _amount);\n    }\n\n    // Withdraw CAKE tokens from STAKING.\n    function leaveStaking(uint256 _amount) public {\n        PoolInfo storage pool = poolInfo[0];\n        UserInfo storage user = userInfo[0][msg.sender];\n        require(user.amount >= _amount, \"withdraw: not good\");\n        updatePool(0);\n        uint256 pending = user.amount.mul(pool.accCakePerShare).div(1e12).sub(user.rewardDebt);\n        if(pending > 0) {\n            safeCakeTransfer(msg.sender, pending);\n        }\n        if(_amount > 0) {\n            user.amount = user.amount.sub(_amount);\n            pool.lpToken.safeTransfer(address(msg.sender), _amount);\n        }\n        user.rewardDebt = user.amount.mul(pool.accCakePerShare).div(1e12);\n\n        syrup.burn(msg.sender, _amount);\n        emit Withdraw(msg.sender, 0, _amount);\n    }\n\n    // Withdraw without caring about rewards. EMERGENCY ONLY.\n    function emergencyWithdraw(uint256 _pid) public {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        pool.lpToken.safeTransfer(address(msg.sender), user.amount);\n        emit EmergencyWithdraw(msg.sender, _pid, user.amount);\n        user.amount = 0;\n        user.rewardDebt = 0;\n    }\n\n    // Safe cake transfer function, just in case if rounding error causes pool to not have enough CAKEs.\n    function safeCakeTransfer(address _to, uint256 _amount) internal {\n        syrup.safeCakeTransfer(_to, _amount);\n    }\n\n    // Update dev address by the previous dev.\n    function dev(address _devaddr) public {\n        require(msg.sender == devaddr, \"dev: wut?\");\n        devaddr = _devaddr;\n    }\n}"
    },
    "@pancakeswap/pancake-swap-lib/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.4.0;\n\nimport '../GSN/Context.sol';\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), 'Ownable: caller is not the owner');\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), 'Ownable: new owner is the zero address');\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "contracts/lib/@pancakeswap/interfaces/IMigratorChef.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport {IBEP20} from \"@pancakeswap/pancake-swap-lib/contracts/token/BEP20/IBEP20.sol\";\n\ninterface IMigratorChef {\n    // Perform LP token migration from legacy PancakeSwap to CakeSwap.\n    // Take the current LP token address and return the new LP token address.\n    // Migrator should have full access to the caller's LP token.\n    // Return the new LP token address.\n    //\n    // XXX Migrator must have allowance access to PancakeSwap LP tokens.\n    // CakeSwap must mint EXACTLY the same amount of CakeSwap LP tokens or\n    // else something bad will happen. Traditional PancakeSwap does not\n    // do that so be careful!\n    function migrate(IBEP20 token) external returns (IBEP20);\n}"
    },
    "contracts/lib/@pancakeswap/CakeToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport {BEP20} from \"@pancakeswap/pancake-swap-lib/contracts/token/BEP20/BEP20.sol\";\n\n// CakeToken with Governance.\ncontract CakeToken is BEP20('PancakeSwap Token', 'Cake') {\n    /// @notice Creates `_amount` token to `_to`. Must only be called by the owner (MasterChef).\n    function mint(address _to, uint256 _amount) public onlyOwner {\n        _mint(_to, _amount);\n        _moveDelegates(address(0), _delegates[_to], _amount);\n    }\n\n    // Copied and modified from YAM code:\n    // https://github.com/yam-finance/yam-protocol/blob/master/contracts/token/YAMGovernanceStorage.sol\n    // https://github.com/yam-finance/yam-protocol/blob/master/contracts/token/YAMGovernance.sol\n    // Which is copied and modified from COMPOUND:\n    // https://github.com/compound-finance/compound-protocol/blob/master/contracts/Governance/Comp.sol\n\n    /// @notice A record of each accounts delegate\n    mapping (address => address) internal _delegates;\n\n    /// @notice A checkpoint for marking number of votes from a given block\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint256 votes;\n    }\n\n    /// @notice A record of votes checkpoints for each account, by index\n    mapping (address => mapping (uint32 => Checkpoint)) public checkpoints;\n\n    /// @notice The number of checkpoints for each account\n    mapping (address => uint32) public numCheckpoints;\n\n    /// @notice The EIP-712 typehash for the contract's domain\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract\n    bytes32 public constant DELEGATION_TYPEHASH = keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n    /// @notice A record of states for signing / validating signatures\n    mapping (address => uint) public nonces;\n\n      /// @notice An event thats emitted when an account changes its delegate\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n\n    /// @notice An event thats emitted when a delegate account's vote balance changes\n    event DelegateVotesChanged(address indexed delegate, uint previousBalance, uint newBalance);\n\n    /**\n     * @notice Delegate votes from `msg.sender` to `delegatee`\n     * @param delegator The address to get delegatee for\n     */\n    function delegates(address delegator)\n        external\n        view\n        returns (address)\n    {\n        return _delegates[delegator];\n    }\n\n   /**\n    * @notice Delegate votes from `msg.sender` to `delegatee`\n    * @param delegatee The address to delegate votes to\n    */\n    function delegate(address delegatee) external {\n        return _delegate(msg.sender, delegatee);\n    }\n\n    /**\n     * @notice Delegates votes from signatory to `delegatee`\n     * @param delegatee The address to delegate votes to\n     * @param nonce The contract state required to match the signature\n     * @param expiry The time at which to expire the signature\n     * @param v The recovery byte of the signature\n     * @param r Half of the ECDSA signature pair\n     * @param s Half of the ECDSA signature pair\n     */\n    function delegateBySig(\n        address delegatee,\n        uint nonce,\n        uint expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    )\n        external\n    {\n        bytes32 domainSeparator = keccak256(\n            abi.encode(\n                DOMAIN_TYPEHASH,\n                keccak256(bytes(name())),\n                getChainId(),\n                address(this)\n            )\n        );\n\n        bytes32 structHash = keccak256(\n            abi.encode(\n                DELEGATION_TYPEHASH,\n                delegatee,\n                nonce,\n                expiry\n            )\n        );\n\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                domainSeparator,\n                structHash\n            )\n        );\n\n        address signatory = ecrecover(digest, v, r, s);\n        require(signatory != address(0), \"CAKE::delegateBySig: invalid signature\");\n        require(nonce == nonces[signatory]++, \"CAKE::delegateBySig: invalid nonce\");\n        require(now <= expiry, \"CAKE::delegateBySig: signature expired\");\n        return _delegate(signatory, delegatee);\n    }\n\n    /**\n     * @notice Gets the current votes balance for `account`\n     * @param account The address to get votes balance\n     * @return The number of current votes for `account`\n     */\n    function getCurrentVotes(address account)\n        external\n        view\n        returns (uint256)\n    {\n        uint32 nCheckpoints = numCheckpoints[account];\n        return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\n    }\n\n    /**\n     * @notice Determine the prior number of votes for an account as of a block number\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n     * @param account The address of the account to check\n     * @param blockNumber The block number to get the vote balance at\n     * @return The number of votes the account had as of the given block\n     */\n    function getPriorVotes(address account, uint blockNumber)\n        external\n        view\n        returns (uint256)\n    {\n        require(blockNumber < block.number, \"CAKE::getPriorVotes: not yet determined\");\n\n        uint32 nCheckpoints = numCheckpoints[account];\n        if (nCheckpoints == 0) {\n            return 0;\n        }\n\n        // First check most recent balance\n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\n            return checkpoints[account][nCheckpoints - 1].votes;\n        }\n\n        // Next check implicit zero balance\n        if (checkpoints[account][0].fromBlock > blockNumber) {\n            return 0;\n        }\n\n        uint32 lower = 0;\n        uint32 upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            Checkpoint memory cp = checkpoints[account][center];\n            if (cp.fromBlock == blockNumber) {\n                return cp.votes;\n            } else if (cp.fromBlock < blockNumber) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return checkpoints[account][lower].votes;\n    }\n\n    function _delegate(address delegator, address delegatee)\n        internal\n    {\n        address currentDelegate = _delegates[delegator];\n        uint256 delegatorBalance = balanceOf(delegator); // balance of underlying CAKEs (not scaled);\n        _delegates[delegator] = delegatee;\n\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n\n        _moveDelegates(currentDelegate, delegatee, delegatorBalance);\n    }\n\n    function _moveDelegates(address srcRep, address dstRep, uint256 amount) internal {\n        if (srcRep != dstRep && amount > 0) {\n            if (srcRep != address(0)) {\n                // decrease old representative\n                uint32 srcRepNum = numCheckpoints[srcRep];\n                uint256 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\n                uint256 srcRepNew = srcRepOld.sub(amount);\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\n            }\n\n            if (dstRep != address(0)) {\n                // increase new representative\n                uint32 dstRepNum = numCheckpoints[dstRep];\n                uint256 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\n                uint256 dstRepNew = dstRepOld.add(amount);\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\n            }\n        }\n    }\n\n    function _writeCheckpoint(\n        address delegatee,\n        uint32 nCheckpoints,\n        uint256 oldVotes,\n        uint256 newVotes\n    )\n        internal\n    {\n        uint32 blockNumber = safe32(block.number, \"CAKE::_writeCheckpoint: block number exceeds 32 bits\");\n\n        if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\n            checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\n        } else {\n            checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\n            numCheckpoints[delegatee] = nCheckpoints + 1;\n        }\n\n        emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\n    }\n\n    function safe32(uint n, string memory errorMessage) internal pure returns (uint32) {\n        require(n < 2**32, errorMessage);\n        return uint32(n);\n    }\n\n    function getChainId() internal pure returns (uint) {\n        uint256 chainId;\n        assembly { chainId := chainid() }\n        return chainId;\n    }\n}"
    },
    "contracts/lib/@pancakeswap/SyrupBar.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport {BEP20} from \"@pancakeswap/pancake-swap-lib/contracts/token/BEP20/BEP20.sol\";\nimport {CakeToken} from \"./CakeToken.sol\";\n\n// SyrupBar with Governance.\ncontract SyrupBar is BEP20('SyrupBar Token', 'SYRUP') {\n    /// @notice Creates `_amount` token to `_to`. Must only be called by the owner (MasterChef).\n    function mint(address _to, uint256 _amount) public onlyOwner {\n        _mint(_to, _amount);\n        _moveDelegates(address(0), _delegates[_to], _amount);\n    }\n\n    function burn(address _from ,uint256 _amount) public onlyOwner {\n        _burn(_from, _amount);\n        _moveDelegates(address(0), _delegates[_from], _amount);\n    }\n\n    // The CAKE TOKEN!\n    CakeToken public cake;\n\n\n    constructor(\n        CakeToken _cake\n    ) public {\n        cake = _cake;\n    }\n\n    // Safe cake transfer function, just in case if rounding error causes pool to not have enough CAKEs.\n    function safeCakeTransfer(address _to, uint256 _amount) public onlyOwner {\n        uint256 cakeBal = cake.balanceOf(address(this));\n        if (_amount > cakeBal) {\n            cake.transfer(_to, cakeBal);\n        } else {\n            cake.transfer(_to, _amount);\n        }\n    }\n\n    // Copied and modified from YAM code:\n    // https://github.com/yam-finance/yam-protocol/blob/master/contracts/token/YAMGovernanceStorage.sol\n    // https://github.com/yam-finance/yam-protocol/blob/master/contracts/token/YAMGovernance.sol\n    // Which is copied and modified from COMPOUND:\n    // https://github.com/compound-finance/compound-protocol/blob/master/contracts/Governance/Comp.sol\n\n    /// @notice A record of each accounts delegate\n    mapping (address => address) internal _delegates;\n\n    /// @notice A checkpoint for marking number of votes from a given block\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint256 votes;\n    }\n\n    /// @notice A record of votes checkpoints for each account, by index\n    mapping (address => mapping (uint32 => Checkpoint)) public checkpoints;\n\n    /// @notice The number of checkpoints for each account\n    mapping (address => uint32) public numCheckpoints;\n\n    /// @notice The EIP-712 typehash for the contract's domain\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract\n    bytes32 public constant DELEGATION_TYPEHASH = keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n    /// @notice A record of states for signing / validating signatures\n    mapping (address => uint) public nonces;\n\n      /// @notice An event thats emitted when an account changes its delegate\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n\n    /// @notice An event thats emitted when a delegate account's vote balance changes\n    event DelegateVotesChanged(address indexed delegate, uint previousBalance, uint newBalance);\n\n    /**\n     * @notice Delegate votes from `msg.sender` to `delegatee`\n     * @param delegator The address to get delegatee for\n     */\n    function delegates(address delegator)\n        external\n        view\n        returns (address)\n    {\n        return _delegates[delegator];\n    }\n\n   /**\n    * @notice Delegate votes from `msg.sender` to `delegatee`\n    * @param delegatee The address to delegate votes to\n    */\n    function delegate(address delegatee) external {\n        return _delegate(msg.sender, delegatee);\n    }\n\n    /**\n     * @notice Delegates votes from signatory to `delegatee`\n     * @param delegatee The address to delegate votes to\n     * @param nonce The contract state required to match the signature\n     * @param expiry The time at which to expire the signature\n     * @param v The recovery byte of the signature\n     * @param r Half of the ECDSA signature pair\n     * @param s Half of the ECDSA signature pair\n     */\n    function delegateBySig(\n        address delegatee,\n        uint nonce,\n        uint expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    )\n        external\n    {\n        bytes32 domainSeparator = keccak256(\n            abi.encode(\n                DOMAIN_TYPEHASH,\n                keccak256(bytes(name())),\n                getChainId(),\n                address(this)\n            )\n        );\n\n        bytes32 structHash = keccak256(\n            abi.encode(\n                DELEGATION_TYPEHASH,\n                delegatee,\n                nonce,\n                expiry\n            )\n        );\n\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                domainSeparator,\n                structHash\n            )\n        );\n\n        address signatory = ecrecover(digest, v, r, s);\n        require(signatory != address(0), \"CAKE::delegateBySig: invalid signature\");\n        require(nonce == nonces[signatory]++, \"CAKE::delegateBySig: invalid nonce\");\n        require(now <= expiry, \"CAKE::delegateBySig: signature expired\");\n        return _delegate(signatory, delegatee);\n    }\n\n    /**\n     * @notice Gets the current votes balance for `account`\n     * @param account The address to get votes balance\n     * @return The number of current votes for `account`\n     */\n    function getCurrentVotes(address account)\n        external\n        view\n        returns (uint256)\n    {\n        uint32 nCheckpoints = numCheckpoints[account];\n        return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\n    }\n\n    /**\n     * @notice Determine the prior number of votes for an account as of a block number\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n     * @param account The address of the account to check\n     * @param blockNumber The block number to get the vote balance at\n     * @return The number of votes the account had as of the given block\n     */\n    function getPriorVotes(address account, uint blockNumber)\n        external\n        view\n        returns (uint256)\n    {\n        require(blockNumber < block.number, \"CAKE::getPriorVotes: not yet determined\");\n\n        uint32 nCheckpoints = numCheckpoints[account];\n        if (nCheckpoints == 0) {\n            return 0;\n        }\n\n        // First check most recent balance\n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\n            return checkpoints[account][nCheckpoints - 1].votes;\n        }\n\n        // Next check implicit zero balance\n        if (checkpoints[account][0].fromBlock > blockNumber) {\n            return 0;\n        }\n\n        uint32 lower = 0;\n        uint32 upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            Checkpoint memory cp = checkpoints[account][center];\n            if (cp.fromBlock == blockNumber) {\n                return cp.votes;\n            } else if (cp.fromBlock < blockNumber) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return checkpoints[account][lower].votes;\n    }\n\n    function _delegate(address delegator, address delegatee)\n        internal\n    {\n        address currentDelegate = _delegates[delegator];\n        uint256 delegatorBalance = balanceOf(delegator); // balance of underlying CAKEs (not scaled);\n        _delegates[delegator] = delegatee;\n\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n\n        _moveDelegates(currentDelegate, delegatee, delegatorBalance);\n    }\n\n    function _moveDelegates(address srcRep, address dstRep, uint256 amount) internal {\n        if (srcRep != dstRep && amount > 0) {\n            if (srcRep != address(0)) {\n                // decrease old representative\n                uint32 srcRepNum = numCheckpoints[srcRep];\n                uint256 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\n                uint256 srcRepNew = srcRepOld.sub(amount);\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\n            }\n\n            if (dstRep != address(0)) {\n                // increase new representative\n                uint32 dstRepNum = numCheckpoints[dstRep];\n                uint256 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\n                uint256 dstRepNew = dstRepOld.add(amount);\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\n            }\n        }\n    }\n\n    function _writeCheckpoint(\n        address delegatee,\n        uint32 nCheckpoints,\n        uint256 oldVotes,\n        uint256 newVotes\n    )\n        internal\n    {\n        uint32 blockNumber = safe32(block.number, \"CAKE::_writeCheckpoint: block number exceeds 32 bits\");\n\n        if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\n            checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\n        } else {\n            checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\n            numCheckpoints[delegatee] = nCheckpoints + 1;\n        }\n\n        emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\n    }\n\n    function safe32(uint n, string memory errorMessage) internal pure returns (uint32) {\n        require(n < 2**32, errorMessage);\n        return uint32(n);\n    }\n\n    function getChainId() internal pure returns (uint) {\n        uint256 chainId;\n        assembly { chainId := chainid() }\n        return chainId;\n    }\n}"
    },
    "@pancakeswap/pancake-swap-lib/contracts/GSN/Context.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.4.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\ncontract Context {\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n    constructor() internal {}\n\n    function _msgSender() internal view returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "@pancakeswap/pancake-swap-lib/contracts/token/BEP20/BEP20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.4.0;\n\nimport '../../access/Ownable.sol';\nimport '../../GSN/Context.sol';\nimport './IBEP20.sol';\nimport '../../math/SafeMath.sol';\nimport '../../utils/Address.sol';\n\n/**\n * @dev Implementation of the {IBEP20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {BEP20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-BEP20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of BEP20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IBEP20-approve}.\n */\ncontract BEP20 is Context, IBEP20, Ownable {\n    using SafeMath for uint256;\n    using Address for address;\n\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name, string memory symbol) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the bep token owner.\n     */\n    function getOwner() external override view returns (address) {\n        return owner();\n    }\n\n    /**\n     * @dev Returns the token name.\n     */\n    function name() public override view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the token decimals.\n     */\n    function decimals() public override view returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev Returns the token symbol.\n     */\n    function symbol() public override view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {BEP20-totalSupply}.\n     */\n    function totalSupply() public override view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {BEP20-balanceOf}.\n     */\n    function balanceOf(address account) public override view returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {BEP20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {BEP20-allowance}.\n     */\n    function allowance(address owner, address spender) public override view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {BEP20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {BEP20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {BEP20};\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for `sender`'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(\n            sender,\n            _msgSender(),\n            _allowances[sender][_msgSender()].sub(amount, 'BEP20: transfer amount exceeds allowance')\n        );\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {BEP20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {BEP20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(\n            _msgSender(),\n            spender,\n            _allowances[_msgSender()][spender].sub(subtractedValue, 'BEP20: decreased allowance below zero')\n        );\n        return true;\n    }\n\n    /**\n     * @dev Creates `amount` tokens and assigns them to `msg.sender`, increasing\n     * the total supply.\n     *\n     * Requirements\n     *\n     * - `msg.sender` must be the token owner\n     */\n    function mint(uint256 amount) public onlyOwner returns (bool) {\n        _mint(_msgSender(), amount);\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal {\n        require(sender != address(0), 'BEP20: transfer from the zero address');\n        require(recipient != address(0), 'BEP20: transfer to the zero address');\n\n        _balances[sender] = _balances[sender].sub(amount, 'BEP20: transfer amount exceeds balance');\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal {\n        require(account != address(0), 'BEP20: mint to the zero address');\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal {\n        require(account != address(0), 'BEP20: burn from the zero address');\n\n        _balances[account] = _balances[account].sub(amount, 'BEP20: burn amount exceeds balance');\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal {\n        require(owner != address(0), 'BEP20: approve from the zero address');\n        require(spender != address(0), 'BEP20: approve to the zero address');\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\n     * from the caller's allowance.\n     *\n     * See {_burn} and {_approve}.\n     */\n    function _burnFrom(address account, uint256 amount) internal {\n        _burn(account, amount);\n        _approve(\n            account,\n            _msgSender(),\n            _allowances[account][_msgSender()].sub(amount, 'BEP20: burn amount exceeds allowance')\n        );\n    }\n}\n"
    },
    "contracts/RewardToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\nimport \"@pancakeswap/pancake-swap-lib/contracts/token/BEP20/BEP20.sol\";\n\n// Mock Reward Token - Testing Only\ncontract RewardToken is BEP20(\"FARM Reward Token\", \"bFARM\") {\n\n  function faucet(uint256 amount) external {\n    _mint(msg.sender, amount);\n  }\n}\n"
    },
    "contracts/lib/@harvest-finance/strategies/VaultMigratorStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport {Address} from \"@pancakeswap/pancake-swap-lib/contracts/utils/Address.sol\";\nimport {SafeMath} from \"@pancakeswap/pancake-swap-lib/contracts/math/SafeMath.sol\";\nimport {IBEP20} from \"@pancakeswap/pancake-swap-lib/contracts/token/BEP20/IBEP20.sol\";\nimport {SafeBEP20} from \"@pancakeswap/pancake-swap-lib/contracts/token/BEP20/SafeBEP20.sol\";\nimport {IStrategy} from \"../hardworkInterface/IStrategy.sol\";\nimport { Controllable } from \"../Controllable.sol\";\nimport {IMigrator} from \"../hardworkInterface/IMigrator.sol\";\nimport {IVault} from \"../hardworkInterface/IVault.sol\";\n\n\ncontract VaultMigratorStrategy is IStrategy, Controllable {\n  using SafeBEP20 for IBEP20;\n  using Address for address;\n  using SafeMath for uint256;\n\n  address public override underlying;\n  address public override vault;\n  address public newVault;\n  address public migrator;\n  mapping(address => bool) public override unsalvagableTokens;\n\n  constructor(\n    address _storage,\n    address _underlying,\n    address _vault,\n    address _newVault\n  ) \n    public\n    Controllable(_storage)\n  {\n    require(_underlying != address(0), \"_underlying cannot be empty\");\n    require(_vault != address(0), \"_vault cannot be empty\");\n    require(_newVault != address(0), \"_newVault cannot be empty\");\n\n    require(IVault(_newVault).underlying() == _underlying, \"underlying must match\");\n\n    unsalvagableTokens[_underlying] = true;\n    underlying = _underlying;\n    vault = _vault;\n    newVault = _newVault;\n  }\n\n  modifier restricted() {\n    require(msg.sender == vault || msg.sender == address(controller()) || msg.sender == address(governance()),\n      \"The sender has to be the controller or vault or governance\");\n    _;\n  }\n\n  function depositArbCheck() public view override returns(bool) {\n    return false; // disable deposits\n  }\n\n  modifier onlyVault() {\n    require(msg.sender == address(vault), \"The caller must be the vault\");\n    _;\n  }\n\n  /*\n  * Returns the total amount.\n  */\n  function investedUnderlyingBalance() view public override returns (uint256) {\n    return IBEP20(underlying).balanceOf(address(this));\n  }\n\n  /*\n  * Invests all tokens that were accumulated so far\n  */\n  function investAllUnderlying() public {\n    // a no-op\n  }\n\n  function setMigrator(address _migrator) external onlyGovernance {\n    migrator = _migrator;\n  }\n\n  function rebalance() public {\n    // a no-op\n  }\n\n  /*\n  * withdraws to the vault (in case migration is aborted)\n  */\n  function withdrawAllToVault() external override restricted {\n    uint256 balance = IBEP20(underlying).balanceOf(address(this));\n    IBEP20(underlying).safeTransfer(address(vault), balance);\n  }\n\n  /*\n  * Cashes some amount out and withdraws to the vault\n  */\n  function withdrawToVault(uint256 amountWei) external override restricted {\n    revert(\"Withdraws through this strategy are disabled\");\n  }\n\n  // initiates the migration. Assumes all underling balance is already\n  // in the strategy (transferred from the vault by doHardWork)\n  function migrateToNewVault() external onlyGovernance {\n    uint256 entireUnderlyingBalance = IBEP20(underlying).balanceOf(address(this));\n\n    uint256 newVaultBalanceBefore = IBEP20(underlying).balanceOf(newVault);\n    IBEP20(underlying).safeApprove(newVault, 0);\n    IBEP20(underlying).safeApprove(newVault, entireUnderlyingBalance);\n    IVault(newVault).deposit(entireUnderlyingBalance);\n    require(IBEP20(underlying).balanceOf(newVault).sub(newVaultBalanceBefore) == entireUnderlyingBalance, \"underlying balance mismatch\");\n\n    uint256 entireShareBalance = IBEP20(newVault).balanceOf(address(this));\n\n    require(migrator != address(0), \"Migrator not set!\");\n    uint256 migratorBalanceBefore = IBEP20(newVault).balanceOf(migrator);\n    IBEP20(newVault).safeApprove(migrator, 0);\n    IBEP20(newVault).safeApprove(migrator, entireShareBalance);\n    IMigrator(migrator).pullFromStrategy();\n    require(IBEP20(newVault).balanceOf(migrator).sub(migratorBalanceBefore) == entireShareBalance, \"share balance mismatch\");\n  }\n\n  function doHardWork() external override onlyVault {\n    // a no-op\n  }\n\n  // should only be called by controller\n  function salvage(address destination, address token, uint256 amount) external override restricted {\n    require(!unsalvagableTokens[token], \"token is defined as not salvageable\");\n    IBEP20(token).safeTransfer(destination, amount);\n  }\n}"
    },
    "contracts/lib/@harvest-finance/hardworkInterface/IMigrator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\ninterface IMigrator {\n    function pullFromStrategy() external;\n}\n"
    },
    "contracts/lib/@harvest-finance/Controller.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\nimport \"@pancakeswap/pancake-swap-lib/contracts/utils/Address.sol\";\nimport \"@pancakeswap/pancake-swap-lib/contracts/math/SafeMath.sol\";\nimport \"@pancakeswap/pancake-swap-lib/contracts/token/BEP20/SafeBEP20.sol\";\nimport \"@pancakeswap/pancake-swap-lib/contracts/token/BEP20/IBEP20.sol\";\nimport \"./hardworkInterface/IController.sol\";\nimport \"./hardworkInterface/IStrategy.sol\";\nimport \"./hardworkInterface/IVault.sol\";\nimport \"./FeeRewardForwarder.sol\";\nimport \"./Governable.sol\";\nimport \"./HardRewards.sol\";\n\ncontract Controller is IController, Governable {\n\n    using SafeBEP20 for IBEP20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    // external parties\n    address public feeRewardForwarder;\n\n    // [Grey list]\n    // An EOA can safely interact with the system no matter what.\n    // If you're using Metamask, you're using an EOA.\n    // Only smart contracts may be affected by this grey list.\n    //\n    // This contract will not be able to ban any EOA from the system\n    // even if an EOA is being added to the greyList, he/she will still be able\n    // to interact with the whole system as if nothing happened.\n    // Only smart contracts will be affected by being added to the greyList.\n    mapping (address => bool) public override greyList;\n\n    // All vaults that we have\n    mapping (address => bool) public vaults;\n\n    // Rewards for hard work. Nullable.\n    HardRewards public hardRewards;\n\n    uint256 public constant override profitSharingNumerator = 5;\n    uint256 public constant override profitSharingDenominator = 100;\n\n    event SharePriceChangeLog(\n      address indexed vault,\n      address indexed strategy,\n      uint256 oldSharePrice,\n      uint256 newSharePrice,\n      uint256 timestamp\n    );\n\n    modifier validVault(address _vault){\n        require(vaults[_vault], \"vault does not exist\");\n        _;\n    }\n\n    modifier confirmSharePrice(\n        address vault,\n        uint256 hint,\n        uint256 deviationNumerator,\n        uint256 deviationDenominator\n    ) {\n        uint256 sharePrice = IVault(vault).getPricePerFullShare();\n        uint256 resolution = 1e18;\n        if (sharePrice > hint) {\n            require(\n                sharePrice.mul(resolution).div(hint) <= deviationNumerator.mul(resolution).div(deviationDenominator),\n                \"share price deviation\"\n            );\n        } else {\n            require(\n                hint.mul(resolution).div(sharePrice) <= deviationNumerator.mul(resolution).div(deviationDenominator),\n                \"share price deviation\"\n            );\n        }\n        _;\n    }\n\n    mapping (address => bool) public hardWorkers;\n\n    modifier onlyHardWorkerOrGovernance() {\n        require(hardWorkers[msg.sender] || (msg.sender == governance()),\n        \"only hard worker can call this\");\n        _;\n    }\n\n    constructor(address _storage, address _feeRewardForwarder)\n        Governable(_storage) \n        public \n    {\n        require(_feeRewardForwarder != address(0), \"feeRewardForwarder should not be empty\");\n        feeRewardForwarder = _feeRewardForwarder;\n    }\n\n    function addHardWorker(address _worker) public onlyGovernance {\n      require(_worker != address(0), \"_worker must be defined\");\n      hardWorkers[_worker] = true;\n    }\n\n    function removeHardWorker(address _worker) public onlyGovernance {\n      require(_worker != address(0), \"_worker must be defined\");\n      hardWorkers[_worker] = false;\n    }\n\n    function hasVault(address _vault) external override returns (bool) {\n      return vaults[_vault];\n    }\n\n    // Only smart contracts will be affected by the greyList.\n    function addToGreyList(address _target) public onlyGovernance {\n        greyList[_target] = true;\n    }\n\n    function removeFromGreyList(address _target) public onlyGovernance {\n        greyList[_target] = false;\n    }\n\n    function setFeeRewardForwarder(address _feeRewardForwarder) public onlyGovernance {\n      require(_feeRewardForwarder != address(0), \"new reward forwarder should not be empty\");\n      feeRewardForwarder = _feeRewardForwarder;\n    }\n\n    function addVaultAndStrategy(address _vault, address _strategy) external override onlyGovernance {\n        require(_vault != address(0), \"new vault shouldn't be empty\");\n        require(!vaults[_vault], \"vault already exists\");\n        require(_strategy != address(0), \"new strategy shouldn't be empty\");\n\n        vaults[_vault] = true;\n        // no need to protect against sandwich, because there will be no call to withdrawAll\n        // as the vault and strategy is brand new\n        IVault(_vault).setStrategy(_strategy);\n    }\n\n    function getPricePerFullShare(address _vault) public view returns(uint256) {\n        return IVault(_vault).getPricePerFullShare();\n    }\n\n    function doHardWork(\n        address _vault,\n        uint256 hint,\n        uint256 deviationNumerator,\n        uint256 deviationDenominator\n    ) \n        external \n        override\n        confirmSharePrice(_vault, hint, deviationNumerator, deviationDenominator)\n        onlyHardWorkerOrGovernance\n        validVault(_vault) \n    {\n        uint256 oldSharePrice = IVault(_vault).getPricePerFullShare();\n        IVault(_vault).doHardWork();\n        if (address(hardRewards) != address(0)) {\n            // rewards are an option now\n            hardRewards.rewardMe(msg.sender, _vault);\n        }\n        emit SharePriceChangeLog(\n          _vault,\n          IVault(_vault).strategy(),\n          oldSharePrice,\n          IVault(_vault).getPricePerFullShare(),\n          block.timestamp\n        );\n    }\n\n    function withdrawAll(\n        address _vault,\n        uint256 hint,\n        uint256 deviationNumerator,\n        uint256 deviationDenominator\n    ) \n        external\n        confirmSharePrice(_vault, hint, deviationNumerator, deviationDenominator)\n        onlyGovernance\n        validVault(_vault)\n    {\n        IVault(_vault).withdrawAll();\n    }\n\n    function setStrategy(\n        address _vault,\n        address strategy,\n        uint256 hint,\n        uint256 deviationNumerator,\n        uint256 deviationDenominator\n    ) \n        external\n        confirmSharePrice(_vault, hint, deviationNumerator, deviationDenominator)\n        onlyGovernance\n        validVault(_vault)\n    {\n        IVault(_vault).setStrategy(strategy);\n    }\n\n    function setHardRewards(address _hardRewards) external onlyGovernance {\n        hardRewards = HardRewards(_hardRewards);\n    }\n\n    // transfers token in the controller contract to the governance\n    function salvage(address _token, uint256 _amount) external override onlyGovernance {\n        IBEP20(_token).safeTransfer(governance(), _amount);\n    }\n\n    function salvageStrategy(address _strategy, address _token, uint256 _amount) external override onlyGovernance {\n        // the strategy is responsible for maintaining the list of\n        // salvagable tokens, to make sure that governance cannot come\n        // in and take away the coins\n        IStrategy(_strategy).salvage(governance(), _token, _amount);\n    }\n\n    function notifyFee(address underlying, uint256 fee) external override {\n      if (fee > 0) {\n        IBEP20(underlying).safeTransferFrom(msg.sender, address(this), fee);\n        IBEP20(underlying).safeApprove(feeRewardForwarder, 0);\n        IBEP20(underlying).safeApprove(feeRewardForwarder, fee);\n        FeeRewardForwarder(feeRewardForwarder).poolNotifyFixedTarget(underlying, fee);\n      }\n    }\n}\n"
    },
    "contracts/lib/@harvest-finance/HardRewards.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\nimport {SafeMath} from \"@pancakeswap/pancake-swap-lib/contracts/math/SafeMath.sol\";\nimport {IBEP20} from \"@pancakeswap/pancake-swap-lib/contracts/token/BEP20/IBEP20.sol\";\nimport {SafeBEP20} from \"@pancakeswap/pancake-swap-lib/contracts/token/BEP20/SafeBEP20.sol\";\nimport {Governable} from \"./Governable.sol\";\nimport {Controllable} from \"./Controllable.sol\";\n\ncontract HardRewards is Controllable {\n\n  using SafeMath for uint256;\n  using SafeBEP20 for IBEP20;\n\n  event Rewarded(address indexed recipient, address indexed vault, uint256 amount);\n\n  // token used for rewards\n  IBEP20 public token;\n\n  // how many tokens per each block\n  uint256 public blockReward;\n\n  // vault to the last rewarded block\n  mapping(address => uint256) public lastReward;\n\n  constructor(address _storage, address _token)\n  Controllable(_storage) public {\n    token = IBEP20(_token);\n  }\n\n  /**\n  * Called from the controller after hard work has been done. Defensively avoid\n  * reverting the transaction in this function.\n  */\n  function rewardMe(address recipient, address vault) external onlyController {\n    if (address(token) == address(0) || blockReward == 0) {\n      // no rewards now\n      emit Rewarded(recipient, vault, 0);\n      return;\n    }\n\n    if (lastReward[vault] == 0) {\n      // vault does not exist\n      emit Rewarded(recipient, vault, 0);\n      return;\n    }\n\n    uint256 span = block.number.sub(lastReward[vault]);\n    uint256 reward = blockReward.mul(span);\n\n    if (reward > 0) {\n      uint256 balance = token.balanceOf(address(this));\n      uint256 realReward = balance >= reward ? reward : balance;\n      if (realReward > 0) {\n        token.safeTransfer(recipient, realReward);\n      }\n      emit Rewarded(recipient, vault, realReward);\n    } else {\n      emit Rewarded(recipient, vault, 0);\n    }\n    lastReward[vault] = block.number;\n  }\n\n  function addVault(address _vault) external onlyGovernance {\n    lastReward[_vault] = block.number;\n  }\n\n  function removeVault(address _vault) external onlyGovernance {\n    delete (lastReward[_vault]);\n  }\n\n  /**\n  * Transfers tokens for the new rewards cycle. Allows for changing the rewards setting\n  * at the same time.\n  */\n  function load(address _token, uint256 _rate, uint256 _amount) external onlyGovernance {\n    token = IBEP20(_token);\n    blockReward = _rate;\n    if (address(token) != address(0) && _amount > 0) {\n      token.safeTransferFrom(msg.sender, address(this), _amount);\n    }\n  }\n}\n"
    },
    "contracts/lib/@harvest-finance/strategies/RewardTokenProfitNotifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\nimport {SafeMath} from \"@pancakeswap/pancake-swap-lib/contracts/math/SafeMath.sol\";\nimport {IBEP20} from \"@pancakeswap/pancake-swap-lib/contracts/token/BEP20/IBEP20.sol\";\nimport {SafeBEP20} from \"@pancakeswap/pancake-swap-lib/contracts/token/BEP20/SafeBEP20.sol\";\nimport {IController} from \"../hardworkInterface/IController.sol\";\nimport {Controllable} from \"../Controllable.sol\";\n\ncontract RewardTokenProfitNotifier is Controllable {\n  using SafeMath for uint256;\n  using SafeBEP20 for IBEP20;\n\n  uint256 public profitSharingNumerator;\n  uint256 public profitSharingDenominator;\n  address public rewardToken;\n\n  constructor(\n    address _storage,\n    address _rewardToken\n  ) public Controllable(_storage){\n    rewardToken = _rewardToken;\n    // persist in the state for immutability of the fee\n    profitSharingNumerator = 30; //IController(controller()).profitSharingNumerator();\n    profitSharingDenominator = 100; //IController(controller()).profitSharingDenominator();\n    require(profitSharingNumerator < profitSharingDenominator, \"invalid profit share\");\n  }\n\n  event ProfitLogInReward(uint256 profitAmount, uint256 feeAmount, uint256 timestamp);\n\n  function notifyProfitInRewardToken(uint256 _rewardBalance) internal {\n    if( _rewardBalance > 0 ){\n      uint256 feeAmount = _rewardBalance.mul(profitSharingNumerator).div(profitSharingDenominator);\n      emit ProfitLogInReward(_rewardBalance, feeAmount, block.timestamp);\n      IBEP20(rewardToken).safeApprove(controller(), 0);\n      IBEP20(rewardToken).safeApprove(controller(), feeAmount);\n      \n      IController(controller()).notifyFee(\n        rewardToken,\n        feeAmount\n      );\n    } else {\n      emit ProfitLogInReward(0, 0, block.timestamp);\n    }\n  }\n\n}\n"
    },
    "contracts/lib/@harvest-finance/strategies/ProfitNotifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\nimport \"@pancakeswap/pancake-swap-lib/contracts/math/SafeMath.sol\";\nimport \"@pancakeswap/pancake-swap-lib/contracts/token/BEP20/IBEP20.sol\";\nimport \"@pancakeswap/pancake-swap-lib/contracts/token/BEP20/SafeBEP20.sol\";\nimport \"../hardworkInterface/IController.sol\";\nimport \"../Controllable.sol\";\n\ncontract ProfitNotifier is Controllable {\n  using SafeMath for uint256;\n  using SafeBEP20 for IBEP20;\n\n  uint256 public profitSharingNumerator;\n  uint256 public profitSharingDenominator;\n  address public underlying;\n\n  event ProfitLog(\n    uint256 oldBalance,\n    uint256 newBalance,\n    uint256 feeAmount,\n    uint256 timestamp\n  );\n\n  constructor(\n    address _storage,\n    address _underlying\n  ) public Controllable(_storage){\n    underlying = _underlying;\n    // persist in the state for immutability of the fee\n    profitSharingNumerator = 30; //IController(controller()).profitSharingNumerator();\n    profitSharingDenominator = 100; //IController(controller()).profitSharingDenominator();\n    require(profitSharingNumerator < profitSharingDenominator, \"invalid profit share\");\n  }\n\n  function notifyProfit(uint256 oldBalance, uint256 newBalance) internal {\n    if (newBalance > oldBalance) {\n      uint256 profit = newBalance.sub(oldBalance);\n      uint256 feeAmount = profit.mul(profitSharingNumerator).div(profitSharingDenominator);\n      emit ProfitLog(oldBalance, newBalance, feeAmount, block.timestamp);\n\n      IBEP20(underlying).safeApprove(controller(), 0);\n      IBEP20(underlying).safeApprove(controller(), feeAmount);\n      IController(controller()).notifyFee(\n        underlying,\n        feeAmount\n      );\n    } else {\n      emit ProfitLog(oldBalance, newBalance, 0, block.timestamp);\n    }\n  }\n}\n"
    },
    "contracts/lib/@harvest-finance/NoMintRewardPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n\npragma solidity ^0.6.0;\n\nimport \"./Controllable.sol\";\nimport \"./LPTokenWrapper.sol\";\nimport \"./hardworkInterface/IController.sol\";\nimport \"./hardworkInterface/IRewardDistributionRecipient.sol\";\nimport \"@pancakeswap/pancake-swap-lib/contracts/token/BEP20/IBEP20.sol\";\n\n/*\n*   [Harvest]\n*   This pool doesn't mint.\n*   the rewards should be first transferred to this pool, then get \"notified\"\n*   by calling `notifyRewardAmount`\n*/\n\ncontract NoMintRewardPool is LPTokenWrapper, IRewardDistributionRecipient, Controllable {\n\n    using Address for address;\n\n    IBEP20 public rewardToken;\n    uint256 public duration; // making it not a constant is less gas efficient, but portable\n\n    uint256 public periodFinish = 0;\n    uint256 public rewardRate = 0;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public rewards;\n\n    mapping (address => bool) smartContractStakers;\n\n    // Harvest Migration\n    // lpToken is the target vault\n    address public sourceVault;\n    address public migrationStrategy;\n    bool public canMigrate;\n\n    event RewardAdded(uint256 reward);\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event RewardPaid(address indexed user, uint256 reward);\n    event RewardDenied(address indexed user, uint256 reward);\n    event SmartContractRecorded(address indexed smartContractAddress, address indexed smartContractInitiator);\n\n    // Harvest Migration\n    event Migrated(address indexed account, uint256 legacyShare, uint256 newShare);\n\n    modifier updateReward(address account) {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = lastTimeRewardApplicable();\n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n        _;\n    }\n\n    modifier onlyMigrationStrategy() {\n      require(msg.sender == migrationStrategy, \"sender needs to be migration strategy\");\n      _;\n    }\n\n    // [Hardwork] setting the reward, lpToken, duration, and rewardDistribution for each pool\n    constructor(\n        address _rewardToken,\n        address _lpToken,\n        uint256 _duration,\n        address _rewardDistribution,\n        address _storage,\n        address _sourceVault,\n        address _migrationStrategy\n    ) \n        public\n        IRewardDistributionRecipient(_rewardDistribution)\n        Controllable(_storage) // only used for referencing the grey list\n    {\n        rewardToken = IBEP20(_rewardToken);\n        lpToken = IBEP20(_lpToken);\n        duration = _duration;\n        sourceVault = _sourceVault;\n        migrationStrategy = _migrationStrategy;\n    }\n\n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return SafeMath.min(block.timestamp, periodFinish);\n    }\n\n    function rewardPerToken() public view returns (uint256) {\n        if (totalSupply() == 0) {\n            return rewardPerTokenStored;\n        }\n        return\n            rewardPerTokenStored.add(\n                lastTimeRewardApplicable()\n                    .sub(lastUpdateTime)\n                    .mul(rewardRate)\n                    .mul(1e18)\n                    .div(totalSupply())\n            );\n    }\n\n    function earned(address account) public view returns (uint256) {\n        return\n            balanceOf(account)\n                .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\n                .div(1e18)\n                .add(rewards[account]);\n    }\n\n    // stake visibility is public as overriding LPTokenWrapper's stake() function\n    function stake(uint256 amount) public override updateReward(msg.sender) {\n        require(amount > 0, \"Cannot stake 0\");\n        recordSmartContract();\n\n        super.stake(amount);\n        emit Staked(msg.sender, amount);\n    }\n\n    function withdraw(uint256 amount) public override updateReward(msg.sender) {\n        require(amount > 0, \"Cannot withdraw 0\");\n        super.withdraw(amount);\n        emit Withdrawn(msg.sender, amount);\n    }\n\n    function exit() external {\n        withdraw(balanceOf(msg.sender));\n        getReward();\n    }\n\n    /// A push mechanism for accounts that have not claimed their rewards for a long time.\n    /// The implementation is semantically analogous to getReward(), but uses a push pattern\n    /// instead of pull pattern.\n    function pushReward(address recipient) public updateReward(recipient) onlyGovernance {\n        uint256 reward = earned(recipient);\n        if (reward > 0) {\n            rewards[recipient] = 0;\n            // If it is a normal user and not smart contract,\n            // then the requirement will pass\n            // If it is a smart contract, then\n            // make sure that it is not on our greyList.\n            if (!recipient.isContract() || !IController(controller()).greyList(recipient)) {\n                rewardToken.safeTransfer(recipient, reward);\n                emit RewardPaid(recipient, reward);\n            } else {\n                emit RewardDenied(recipient, reward);\n            }\n        }\n    }\n\n    function getReward() public updateReward(msg.sender) {\n        uint256 reward = earned(msg.sender);\n        if (reward > 0) {\n            rewards[msg.sender] = 0;\n            // If it is a normal user and not smart contract,\n            // then the requirement will pass\n            // If it is a smart contract, then\n            // make sure that it is not on our greyList.\n            if (tx.origin == msg.sender || !IController(controller()).greyList(msg.sender)) {\n                rewardToken.safeTransfer(msg.sender, reward);\n                emit RewardPaid(msg.sender, reward);\n            } else {\n                emit RewardDenied(msg.sender, reward);\n            }\n        }\n    }\n\n    function notifyRewardAmount(uint256 reward)\n        external\n        override \n        onlyRewardDistribution\n        updateReward(address(0))\n    {\n        // overflow fix according to https://sips.synthetix.io/sips/sip-77\n        require(reward < uint(-1) / 1e18, \"the notified reward cannot invoke multiplication overflow\");\n\n        if (block.timestamp >= periodFinish) {\n            rewardRate = reward.div(duration);\n        } else {\n            uint256 remaining = periodFinish.sub(block.timestamp);\n            uint256 leftover = remaining.mul(rewardRate);\n            rewardRate = reward.add(leftover).div(duration);\n        }\n        lastUpdateTime = block.timestamp;\n        periodFinish = block.timestamp.add(duration);\n        emit RewardAdded(reward);\n    }\n\n    // Harvest Smart Contract recording\n    function recordSmartContract() internal {\n      if( tx.origin != msg.sender ) {\n        smartContractStakers[msg.sender] = true;\n        emit SmartContractRecorded(msg.sender, tx.origin);\n      }\n    }\n\n\n    // Harvest Migrate\n\n    function setCanMigrate(bool _canMigrate) public onlyGovernance {\n      canMigrate = _canMigrate;\n    }\n\n    // obtain the legacy vault sahres from the migration strategy\n    function pullFromStrategy() public onlyMigrationStrategy {\n      canMigrate = true;\n      lpToken.safeTransferFrom(msg.sender, address(this),lpToken.balanceOf(msg.sender));\n    }\n\n    // called only by migrate() \n    function migrateStakeFor(address target, uint256 amountNewShare) internal override updateReward(target) {\n      super.migrateStakeFor(target, amountNewShare);\n      emit Staked(target, amountNewShare);\n    }\n\n    // The MigrationHelperReward Pool already holds the shares of the targetVault\n    // the users are coming with the old share to exchange for the new one\n    // We want to incentivize the user to migrate, thus we will not stake for them before they migrate.\n    // We also want to save user some hassle, thus when user migrate, we will automatically stake for them\n\n    function migrate() external {\n      require(canMigrate, \"Funds not yet migrated\");\n      recordSmartContract();\n\n      // casting here for readability\n      address targetVault = address(lpToken);\n\n      // total legacy share - migrated legacy shares\n      // What happens when people wrongfully send their shares directly to this pool\n      // without using the migrate() function? The people that are properly migrating would benefit from this.\n      uint256 remainingLegacyShares = (IBEP20(sourceVault).totalSupply()).sub(IBEP20(sourceVault).balanceOf(address(this)));\n\n      // How many new shares does this contract hold?\n      // We cannot get this just by IERC20(targetVault).balanceOf(address(this))\n      // because this contract itself is a reward pool where they stake those vault shares\n      // luckily, reward pool share and the underlying lp token works in 1:1\n      // _totalSupply is the amount that is staked\n      uint256 unmigratedNewShares = IBEP20(targetVault).balanceOf(address(this)).sub(totalSupply());\n      uint256 userLegacyShares = IBEP20(sourceVault).balanceOf(msg.sender);\n      require(userLegacyShares <= remainingLegacyShares, \"impossible for user legacy share to have more than the remaining legacy share\");\n\n      // Because of the assertion above, \n      // we know for sure that userEquivalentNewShares must be less than unmigratedNewShares (the idle tokens sitting in this contract)\n      uint256 userEquivalentNewShares = userLegacyShares.mul(unmigratedNewShares).div(remainingLegacyShares);\n      \n      // Take the old shares from user\n      IBEP20(sourceVault).safeTransferFrom(msg.sender, address(this), userLegacyShares);\n      \n      // User has now migrated, let's stake the idle tokens into the pool for the user\n      migrateStakeFor(msg.sender, userEquivalentNewShares);\n\n      emit Migrated(msg.sender, userLegacyShares, userEquivalentNewShares);\n    }\n}"
    },
    "contracts/lib/@harvest-finance/LPTokenWrapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"@pancakeswap/pancake-swap-lib/contracts/math/SafeMath.sol\";\nimport \"@pancakeswap/pancake-swap-lib/contracts/token/BEP20/IBEP20.sol\";\nimport \"@pancakeswap/pancake-swap-lib/contracts/token/BEP20/SafeBEP20.sol\";\n\n/*\n*   Changes made to the SynthetixReward contract\n*\n*   uni to lpToken, and make it as a parameter of the constructor instead of hardcoded.\n*\n*\n*/\n\ncontract LPTokenWrapper {\n    using SafeMath for uint256;\n    using SafeBEP20 for IBEP20;\n\n    IBEP20 public lpToken;\n\n    uint256 private _totalSupply;\n    mapping(address => uint256) private _balances;\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    function stake(uint256 amount) public virtual {\n        _totalSupply = _totalSupply.add(amount);\n        _balances[msg.sender] = _balances[msg.sender].add(amount);\n        lpToken.safeTransferFrom(msg.sender, address(this), amount);\n    }\n\n    function withdraw(uint256 amount) public virtual {\n        _totalSupply = _totalSupply.sub(amount);\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n        lpToken.safeTransfer(msg.sender, amount);\n    }\n\n    // Harvest migrate\n    // only called by the migrateStakeFor in the MigrationHelperRewardPool\n    function migrateStakeFor(address target, uint256 amountNewShare) internal virtual {\n      _totalSupply = _totalSupply.add(amountNewShare);\n      _balances[target] = _balances[target].add(amountNewShare);\n    }\n}"
    },
    "contracts/lib/@harvest-finance/hardworkInterface/IRewardDistributionRecipient.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"@pancakeswap/pancake-swap-lib/contracts/access/Ownable.sol\";\n\nabstract contract IRewardDistributionRecipient is Ownable {\n    address rewardDistribution;\n\n    constructor(address _rewardDistribution) public {\n        rewardDistribution = _rewardDistribution;\n    }\n\n    function notifyRewardAmount(uint256 reward) external virtual;\n\n    modifier onlyRewardDistribution() {\n        require(_msgSender() == rewardDistribution, \"Caller is not reward distribution\");\n        _;\n    }\n\n    function setRewardDistribution(address _rewardDistribution)\n        external\n        onlyOwner\n    {\n        rewardDistribution = _rewardDistribution;\n    }\n}\n"
    },
    "contracts/lib/@pancakeswap/PancakeFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport {IPancakeFactory} from \"./interfaces/IPancakeFactory.sol\";\nimport {IPancakePair} from \"./interfaces/IPancakePair.sol\";\nimport {PancakePair} from \"./PancakePair.sol\";\n\ncontract PancakeFactory is IPancakeFactory {\n    bytes32 public constant INIT_CODE_PAIR_HASH = keccak256(abi.encodePacked(type(PancakePair).creationCode));\n\n    address public override feeTo;\n    address public override feeToSetter;\n\n    mapping(address => mapping(address => address)) public override getPair;\n    address[] public override allPairs;\n\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    constructor(address _feeToSetter) public {\n        feeToSetter = _feeToSetter;\n    }\n\n    function allPairsLength() external view override returns (uint) {\n        return allPairs.length;\n    }\n\n    function createPair(address tokenA, address tokenB) external override returns (address pair) {\n        require(tokenA != tokenB, 'Pancake: IDENTICAL_ADDRESSES');\n        (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        require(token0 != address(0), 'Pancake: ZERO_ADDRESS');\n        require(getPair[token0][token1] == address(0), 'Pancake: PAIR_EXISTS'); // single check is sufficient\n        bytes memory bytecode = type(PancakePair).creationCode;\n        bytes32 salt = keccak256(abi.encodePacked(token0, token1));\n        assembly {\n            pair := create2(0, add(bytecode, 32), mload(bytecode), salt)\n        }\n        IPancakePair(pair).initialize(token0, token1);\n        getPair[token0][token1] = pair;\n        getPair[token1][token0] = pair; // populate mapping in the reverse direction\n        allPairs.push(pair);\n        emit PairCreated(token0, token1, pair, allPairs.length);\n    }\n\n    function setFeeTo(address _feeTo) external override {\n        require(msg.sender == feeToSetter, 'Pancake: FORBIDDEN');\n        feeTo = _feeTo;\n    }\n\n    function setFeeToSetter(address _feeToSetter) external override {\n        require(msg.sender == feeToSetter, 'Pancake: FORBIDDEN');\n        feeToSetter = _feeToSetter;\n    }\n}"
    },
    "contracts/strategies/venus-protocol/VenusProtocolStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\nimport \"../../lib/@harvest-finance/hardworkInterface/IStrategyV2.sol\";\n\ncontract VenusProtocolStrategy {\n\n}"
    },
    "contracts/lib/@harvest-finance/strategies/upgradability/StrategyProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.0;\n\nimport \"../../hardworkInterface/IUpgradeSource.sol\";\nimport \"../../../@openzeppelin/upgrades/upgradeability/BaseUpgradeabilityProxy.sol\";\n\ncontract StrategyProxy is BaseUpgradeabilityProxy {\n  constructor(address _implementation) public {\n    _setImplementation(_implementation);\n  }\n\n  /**\n  * The main logic. If the timer has elapsed and there is a schedule upgrade,\n  * the governance can upgrade the strategy\n  */\n  function upgrade() external {\n    (bool should, address newImplementation) = IUpgradeSource(address(this)).shouldUpgrade();\n    require(should, \"Upgrade not scheduled\");\n    _upgradeTo(newImplementation);\n\n    // the finalization needs to be executed on itself to update the storage of this proxy\n    // it also needs to be invoked by the governance, not by address(this), so delegatecall is needed\n    (bool success, bytes memory result) = address(this).delegatecall(\n      abi.encodeWithSignature(\"finalizeUpgrade()\")\n    );\n\n    require(success, \"Issue when finalizing the upgrade\");\n  }\n\n  function implementation() external view returns (address) {\n    return _implementation();\n  }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}